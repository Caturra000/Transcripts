# thread_local 如其所是

标题：Thread Local в C++ как он есть

日期：2020/11/19

作者：Евгений Ерохин

链接：[https://www.youtube.com/watch?v=QPoNyMqexuc](https://www.youtube.com/watch?v=QPoNyMqexuc)

注意：此为 **AI 翻译生成** 的中文转录稿，详细说明请参阅仓库中的 [README](/README.md) 文件。

备注一：正在一边看一边手动添加代码和图片，WIP。

备注二：有些地方不知为啥还是俄语，倒是不影响阅读。

-------

好的，那么，请允许我介绍一下我今天报告的主题——`thread_local` 和 C++，如其所是。我叫 Женя Ерохин（叶夫根尼·叶罗欣）。

我想我应该先回答你们的第一个问题，也就是我的背景。

目前，我是 DINS 公司的一名高级开发人员。我们为实时视频传输开发各种服务，也就是基于 RTP 协议的服务。我需要实现各种 RFC，阅读大量文档等等。在此之前，我在 Paragon Software 工作了十多年，在那里我负责一个方向。在某个时期，我甚至是 Mac 文件系统驱动程序的唯一主要开发者。我不得不实现文件系统、从事快照系统、各种引导加载程序、逆向工程以及许多其他系统级的工作。顺便说一句，我们的引导加载程序也使用 C++。驱动程序也全是用 C++ 编写的，所以这里的一切都与 C++ 有关。

当做很多这样的工作，比如逆向工程，观察事物时，总会想看看它内部是什么样的，它是如何组织的。今天，我想向大家介绍我的一项研究成果。

是的，我想向观众提个问题，我们现在在聊天区里提问吧。

对于那些还不太明白 `thread_local` 是什么的人，我来简要描述一下。我们有一些变量，我们希望每个线程都有自己的副本。如果我们有一个线程，当它访问某个变量时，我们希望它拥有自己的那一份，并且只有它能操作这个变量。另一个线程将有自己的副本，并操作它自己的那份。

这只是一个非常简短的描述。我们以什么为基础呢？我们将以 Linux 中的实现为基础。为什么？因为实际上，Linux 目前支持最多样化的 `thread_local` 用法。据我所知，Macintosh 和 Windows 目前还无法夸耀这一点。

现在，简单谈谈它的演进。`thread_local` 最初是作为 POSIX 的一部分出现的，通过一系列命令如 `pthread_getspecific` 和 `pthread_setspecific`。在此之前，还需要调用某些函数来准备好一切。这需要大量的手动工作，而且效率不高。自然，业界不希望一直这样下去。

于是，编译器开发者们介入了。他们添加了——起初形式各异，但最终是——关键词 `__thread`（两个下划线），这还是在 C 语言中。如果我们在变量声明前加上这个关键词，这个变量就变成了该线程的局部变量。只有该线程使用它，每个线程都会有自己的副本。最终，在 C++11 中，它作为标准特性以关键词 `thread_local`（一个下划线后跟 local）的形式出现。

那么，让我们来了解一下 `thread_local` 在机器码中是什么样子的。

假设我们在全局作用域中声明了一个 `thread_local` 变量 `t_sumvar`，然后我们创建一个简单的函数来递增它。

```cpp
thread_local int t_sumvar;

void increment() {
    t_sumvar++;
}
```

现在我们来看汇编代码。这里，这一切都变成了一条指令。也就是说，没有一堆函数调用。只有一条指令，为了看得更清楚一点，它相对于 `fs` 寄存器，在某个偏移量处加 1。也就是执行递增操作。

```
addl    $1, %fs:t_sumvar@TPOFF
```

原则上，这里可能已经很难再优化了。嗯，我们甚至可以给它加上 `-shared` 编译选项（`-fPIC`）。好吧，再想优化恐怕几乎不可能了。哦！

这时，事情似乎不对劲了。当我第一次看到这个时，我是这么想的。一条指令变成了一个 `call` 调用，某种魔法，发生了一些事情。

```
callq   __tls_get_addr@PLT
addl    $1, (%rax)
```

那时，我为自己总结了一个论点：汇编代码永远反映的是“此时此地”的情况。它往往不能告诉我们事物的真正工作原理。但我们稍后会回到这个代码片段。

## 链接基础

所以让我们暂时继续。一切是如何开始的。POSIX。我们来看看操作的顺序。实际上，今天在 POSIX 中一切仍然是这样工作的。为了获取一些线程特有的数据，我们首先需要使用 `pthread_key_create` 创建一个键。然后，我们需要将这个键保存在一个全局变量中，因为所有线程都必须知道通过哪个键来访问数据。如果我们想设置这些数据，我们使用 `pthread_setspecific`。如果需要获取，就用 `pthread_getspecific`。相应地，之后我们还需要清理所有东西，别忘了使用 `pthread_key_delete`。当然，还有一个小不便是我们操作的是 `void*` 指针。也就是说，如果我们想要某种结构体，就需要自己分配内存，你懂的，得自己费心去处理。看到这一系列操作，就很容易想象有多少地方可能出错。因此，一个关键词和来自编译器的某种自动化是必要的。

自然，摆脱复杂性的方法就是使用关键词。它最初以 `__thread` 的形式出现，后来在 C++ 中出现了 `thread_local`。正如我所说，一旦设置了这个关键词，数据就对该线程变为局部，并且所有线程都有自己的副本。

那么，我们可以在哪里使用这个关键词呢？

1. **全局作用域**：在 `main` 函数之前，我们可以定义 `thread_local` 变量。
2. **结构体内部**：当在结构体内部使用时，我们仍然必须使用 `static` 关键词。因为实际上，`thread_local` 变量与静态变量和全局变量是近亲。我认为这里保留这个词是为了让程序员一眼就能看出，这个变量实际上不属于结构体本身的字段。它将被分开存储。但我们将通过结构体的限定符来访问它。
3. **函数内部**：`thread_local` 也可以在函数内部使用。就像我们使用 `static` 会让函数拥有一个全局变量一样，`thread_local` 会让函数在每个线程中都有一个独立的变量副本。

我想这里应该都很清楚了。

另外，从 C++17 开始，我们能够为变量指定 `inline` 说明符，这也包括 `thread_local` 变量。相应地，如果我们在头文件中定义它，编译后会发现，我们最终只有一个实例，而不是一大堆分散在不同模块（或者说目标文件）中的副本。

还有一个小特点，是的，在 GNU 中有所谓的**弱符号**（weak symbols）。可以为 `thread_local` 设置 `weak` 属性。让我稍微解释一下什么是弱符号，因为我们后面会用到它。在 GNU 编译器中，也就是在 ELF 格式、Linux 和许多 Unix 系统中，可以将符号定义为弱符号。在链接的术语中，符号是函数或变量的名称。可以把它声明为“弱化的”，这意味着它实际上可以不存在于代码中。通常，当我们链接某些东西时，我们必须拥有所有符号，否则就会出现链接错误，提示符号未解析。但我们可以在库中将其定义为弱符号，编译器会说，好吧，这个符号不存在，但没关系。唯一的要求是，我们之后必须在代码中明确检查，`if (symbol_name != nullptr)`，这意味着它存在，我们可以使用它。

我们继续。作为工程师，在组织 `thread_local` 存储时，我们必须考虑什么？

- 我们有一个可执行文件，某个二进制文件被加载了，我们自然有 `main` 函数，这是主线程。
- 对于 `thread_local`，会为它创建一个内存块。毕竟我们有变量，就需要内存。
- 接下来，可能会创建新的线程。相应地，每个线程都必须有自己的副本。也就是说，必须为每个线程创建一个内存块来存储所有这些。
- 我们还有 **DSO**（Dynamic Shared Object，动态共享对象）。当它们被加载时，它们也可能有自己的 `thread_local` 变量。相应地，它们也需要自己的内存块，为每个使用它们的线程存储这些变量。
- 在任何时候，都可能有新线程加入，因此也需要为它们分配存储 `thread_local` 变量的空间。
- DSO 也可以在任何时候通过 `dlopen` 加载，通过 `dlclose` 卸载。因此，需要为它们分配和释放块。
- 线程也可能退出。

所以，围绕着一个小小的关键词，我们看到了一个相当有趣的、正在发生的全景图，以及需要考虑的各种情况。

现在，让我们慢慢开始深入了解这一切是如何工作的。

首先，我们给 `thread_local` 变量的生命周期起点下一个稍微粗略的定义。正如从那张动态图片中可以清楚看到的，它要么是**新线程的创建**，要么是**某个共享库的加载**（主要是通过 `dlopen`）。生命周期的终点，自然是当线程退出时，我们必须清除所有 `thread_local` 数据；或者是当 DSO 被卸载时，无论是通过 `dlclose` 还是在线程终止的过程中。

为了支持这一切，文件格式中也做了相应的修改。我们都知道，当我们在全局作用域声明一个变量，比如 `int a = 5;`，这个 5 会被保存在可执行文件的 `.data` 段中。当程序启动时，这个 `.data` 段被复制到为数据分配的内存页中。如果有些数据未初始化或初始化为零，它们的信息会记录在 `.bss` 段中，也就是说，不会为它们在文件中分配空间，但需要记录它们的大小并在运行时将其清零。

为了让 `thread_local` 数据也能实现同样的逻辑，ELF 格式中添加了两个新的段：`.tdata` 和 `.tbss`。逻辑完全相同。当为线程创建数据时，初始化的数据我们从 `.tdata` 中获取；如果有未初始化或清零的数据，我们根据 `.tbss` 的信息来处理它们（更准确地说，是由系统为我们准备和清零）。

当然，**重定位**（relocations）也会参与其中。让我们也简要说明一下什么是重定位，以便大家达成共识。我们有 `.text` 页，这是可执行代码，紧随其后的是数据页，也就是从 `.tdata` 和 `.tbss` 初始化的数据。ELF 可执行文件或 DSO 还有一个重定位表。什么是重定位表？它是一组记录，告诉动态加载器（即提供我们运行时的程序），在将代码和数据内容放置到地址空间的某个地址后，必须在某些地方修正地址，或者填入动态加载器才知道的某些数据。

这里展示了两个主要的修正操作（fixups）：我们修正并设置了某些地址。我用箭头标示出，重定位甚至可以直接作用于代码。但实际上并非总是如此，因为你们肯定知道有**位置无关代码**（Position Independent Code, PIC）和位置相关代码。当我们用 `-fpic` 选项编译时，会生成位置无关代码，这时对代码的重定位就会转移到数据页中。那里有专门组织的表，我们稍后会谈到，所有这些都写在那里。相应地，在代码中只需进行间接寻址，这使我们不必修改代码本身，因此该代码页可以在多个进程之间同时共享。

```
Поддержка в ELF（ELF 中的支持）

* Новые релокации（新的重定位项）
  - R_X86_64_DTPMOD64
  - R_X86_64_DTPOFF64
* Или объединенные в одну запись（或合并为一条记录）
  - R_X86_64_TLSLD
```

现在谈谈 `thread_local` 引入的重定位类型。这里显示了我们主要会看到的两种：`DTPMOD64` 和 `DTPOFF64`，以及一种将它们结合起来的重定位。

- `DTPMOD64`：这个重定位告诉加载器，请在指定的地址处，放入模块的 ID。在链接器或二进制文件的术语中，可执行文件和 DSO 都被称为模块。
- `DTPOFF64`：这个重定位请求加载器放入 `thread_local` 数据相对于其模块 TLS 块基地址的偏移量。

```cpp
// 参考 CSAPP 第七章里面的图吧，幻灯片不好识别转换
```

继续。什么是**位置无关代码**（PIC）以及它是如何使用的？我们需要这些信息来理解后面的部分内容。这里的地址也是从下往上。最下面是代码页 `.text`，我们的程序就在这里。稍高一点是存放我们数据的页面。为了组织这些重定位，引入了一个特殊的表——**GOT**（Global Offset Table，全局偏移表）。它的每个条目都是指针大小，我们在这里存储所有我们需要的指针。也就是说，如果我们需要来自另一个对象的变量，我们通过重定位表请求动态加载器：“请把那个变量的地址放到 GOT 里”。然后，我们的代码将通过这个表进行间接访问。

如果我们要调用函数，它们也需要地址。这些地址被放入 GOT 中，但为了实现懒加载（lazy binding），添加了一些小的、被称为“跳板”（trampolines）的函数。也就是说，当调用函数时，控制流首先进入 **PLT**（Procedure Linkage Table，过程链接表），PLT 从 GOT 中由编译器为其分配的单元格里获取地址。原则上，PLT 本身与 `thread_local` 无关，但你会在汇编示例中经常看到它。

让我们再总结一下这张幻灯片。我们有一个外部的表（GOT），可以在重定位后存储各种地址，然后从代码中去使用它们。它也将用于各种指向 `thread_local` 的指示，通常用于存储模块 ID 和 `thread_local` 数据在其存储区内的偏移量。

## TLS 概念

现在，让我们引入 **TLS**（Thread-Local Storage）的概念。这正是存储我们 `thread_local` 数据的地方。我们有两种变体：**静态 TLS** 和 **动态 TLS**。

- **静态 TLS**：实际上在每个线程启动时创建。它的大小是预先知道的。我们稍后会讨论这个。
- **动态 TLS**：为通过 `dlopen` 启动的库创建。

```
Алгоритм формирования Static TLS

Статический TLS формируется динамическим линковщиком на запуске программы

1. Добавляем TLS исполняемого файла (секции .tbss .tdata)
2. Загружаем прилинкованные DSO
3. Добавляем TLS от загруженных DSO (секции .tbss .tdata)
4. Выделяем один блок на все участвующие модули
5. Некоторые! Рантаймы могут добавлять запасной кусок (surplus)

静态 TLS 的形成算法

静态 TLS 由动态链接器在程序启动时形成

1. 添加可执行文件的 TLS（.tbss、.tdata 部分）
2. 加载已链接的 DSO
3. 添加来自已加载 DSO 的 TLS（.tbss、.tdata 部分）
4. 为所有参与模块分配一个块
5. 某些！运行时可能会添加备用部分（surplus）
```

我们如何计算静态 TLS 的大小呢？应用程序加载过程是这样的：我们启动应用，控制权交给动态加载器。它将我们的二进制文件映射到内存，查看它有哪些共享对象依赖，构建依赖图，并按深度优先的顺序依次加载它们。当整个依赖图构建完毕，所有依赖的库都已加载后，加载器会检查每个模块（二进制文件、DSO）的 `.tbss` 和 `.tdata` 段，并计算它们的总大小。这基本上就是我们静态 TLS 存储区的大小。这样，我们就能满足所有已加载对象的初始需求。此外，通常还会增加一个小小的盈余，比如 1 或 2 KB，以防之后有不频繁的 `dlopen` 加载，这样就可以使用这部分空间，而不必分配单独的内存块。


![fig1](/images/thread-local-in-cpp-as-it-is-1.png)


现在让我们进入更多细节。**TCB**（Thread Control Block，线程控制块）。这是管理任何线程整个生命周期的核心结构。线程生命活动所需的一切都聚集在那里。这里不能不提我们应该感谢谁——**Ulrich Drepper**。他实现了原生线程库（NPTL），我们今天的 `thread_local` 也应归功于他。下面那个链接是主要文档，其中描述了当时几乎所有可能的处理器平台上的各种实现细节和重定位方式。因为我展示的重定位类型只是现有庞大体系中的冰山一角。程序编译后，你基本上只会看到两三种重定位，其余的都在静态链接阶段被处理掉了。

```
https://uclibc.org/docs/tls.pdf
```

现在让我们看看交互是如何进行的。我们的出发点是 **TP**（Thread Pointer，线程指针）。这就是我们在 x86-64 平台上从 `fs` 寄存器中获取的东西。每个线程的 TP 都指向其 `pthread` 结构，该结构的第一个字段通常是一个指向 **DTV**（Dynamic Thread Vector）数组的指针。我们马上会讲到 DTV。我们先看看线程控制块里发生了什么。除了指向这个数组的指针，这里还有一些其他数据，供各种标志、线程启动函数等使用。在它的尾部，附加了我们之前计算好的静态 TLS。

1. 首先是二进制文件本身的 TLS，它需要的内存被分配在这里。
2. 接着是下一个库的 TLS，依此类推。每个库在这里都有自己的存储区。

这整个附在 TCB 上的部分就是静态存储区。但我们原则上如何访问它呢？为此，使用了一个辅助向量 **DTV**。它的第一个字段（索引为 0）是**代号**（generation number）。我马上会解释这个问题。接下来的部分实际上是一个指针数组，指向每个模块独立存储区的基地址。也就是说，第一个索引指向二进制文件存储区的起始位置，下一个指向下一个库的，以此类推。如果在程序运行期间间我们 активно 地使用了 `dlopen`，很明显我们无法预先预测并分配巨大的内存来满足所有可能的动态加载需求。在这里我们必须更加动态。因此，对于单独加载的库，我们不得不为它们分配各自的块。当然，这里做了优化，这些块不会立即分配，而是在它们真正需要时才分配。如果某个线程没有触及那个库，那么分配内存就没有意义，何必浪费内存资源呢？

关于开头的那个**代号**（generation），它告诉我们什么？由于我们的系统是动态的，它有自己的生命周期。模块可以被添加，也可以被移除。在一个并发环境中，持续地遍历所有线程并修改每个线程的 DTV 是没有意义的。因此，每次访问时，我们都会检查它的代号是否与全局的代号计数器相匹配。当一个带有 `thread_local` 变量的对象通过 `dlopen` 加载时，这个全局计数器会增加。相应地，在下一次访问这个 DTV 时，我们会检查代号。当一个库被卸载时，我们同样会增加这个计数器，代号也会增加。

我希望通过这个图表，大部分内容应该都清楚了，但我们稍后肯定会再看一些 уточнения。

![fig2](/images/thread-local-in-cpp-as-it-is-2.png)

实际上，在 Drepper 的原始工作中，有两种模型。为了避免眼花缭乱，我先提示一下，它们几乎是相同的。唯一的区别在于线程指针（Thread Pointer）指向哪里。

- **模型一**：线程指针指向结构的开头，TLS 位于其右侧，即地址空间中更高地址处。
- **模型二**：线程指针指向中间。TCB 本身位于右侧（高地址），而静态存储区则位于左侧（低地址），依次是二进制文件、下一个加载的库等等。

TCB 仍然指向相同的 DTV 向量，所有这些基地址的访问方式也完全一样。它们根据索引指向这些模块的基地址。动态部分也是如此。

当我们在 meetup 上试讲这个报告时，我问大家会选择哪种方案，大多数人倾向于第一种，因为引用一个结构的中间部分，感觉是个奇怪的选择。然而，胜出的是第二种方案。这个方案的优点究竟在哪里，为什么这样的复杂性反而会赢呢？因为在编译阶段，编译器无法确定它将为哪个内核、具备哪些特性进行编译。它事先并不知道这个线程控制块的确切大小。因此，这种方式一方面允许运行时发展并添加新字段，因为 DTV 总是从零偏移处访问，我们可以同样访问到它；另一方面，静态 TLS 全部被放置在低地址处。实际上，DTV 中也有一些带有负偏移的元素，包含长度等信息，但这些都是细节，对于整体方案来说不是特别有趣。

现在让我们看看这一切是如何工作的，以及有哪些变体。

在所谓的经典 TLS 模型中，我们有四种模型，实际上分为两组。两种用于动态库（即可共享库），两种用于可执行文件（`exec` 告诉我们这是可执行文件）。

- **General Dynamic (GD)**：最重、最强大的模型，必须处理最棘手的边界情况。
- **Local Dynamic (LD)**：一个更轻量级的动态模型。
- **Initial Exec (IE)**：用于可执行文件的稍重模型。
- **Local Exec (LE)**：最简单的模型。

让我们看看这一切是如何运作的。我们从最重的开始，其他的就会变得越来越简单。



## General Dynamic (GD)

```
+--------+       +--------+       +--------+
|  BIN   |       | DSO 1  |       | DSO 2  |
|        |       |        |       |        |
|  TLS   |<----->|  [x]   |<----->|  TLS   |
|        |       |        |       |        |
+--------+       +--------+       +--------+
```

这是这样一种模型：编译器正在编译一个共享对象，或者在任何情况下，都是在 `-fpic`（位置无关代码）模式下工作。代码中通过 `extern` 声明了一个变量。我们的 DSO1 并不知道这个变量存储在哪里，它可能在二进制文件的静态 TLS 中，也可能在某个共享对象的动态 TLS 中。也就是说，它拥有的信息最少。它只知道有这样一个符号，并且有人想用它。

为了获取 TLS 本身的地址以及如何处理它，下面这个函数会帮助我们。它直接取自 glibc，虽然看起来很吓人，但实际上它只是组织了我们从 TCB 到 TLS 的那个相当简单的遍历过程。

```cpp
/* 生成代码，仔细甄别 */

// 人工备注：往视频简单对照了一下，基本接近真实代码，gemini 是不是有点哈人了……

void* __tls_get_addr(tls_index* ti) {
    // 简化逻辑
    dtv_t* dtv = THREAD_DTV(); // 1. 从线程指针获取 DTV
    if (dtv->generation != GL(dl_tls_generation)) {
        // 2. 如果代号过时，更新 DTV
        dtv = _dl_update_slotinfo(ti->ti_module);
    }
    void* p = dtv[ti->ti_module].pointer.val; // 3. 从 DTV 获取模块的 TLS 块指针
    if (p == NULL) {
        // 4. 如果未分配，则分配
        p = _dl_allocate_tls(dtv);
    }
    return p + ti->ti_offset; // 5. 返回基地址 + 偏移量
}
```

```cpp
// 人工提取的幻灯片代码
void *__tls_get_addr (GET_ADDR_ARGS)
{
    dtv_t *dtv = THREAD_DTV ();

    if (__glibc_unlikely (dtv[0].counter != GL(dl_tls_generation)))
        return update_get_addr (GET_ADDR_PARAM);

    void *p = dtv[GET_ADDR_MODULE].pointer.val;

    if (__glibc_unlikely (p == TLS_DTV_UNALLOCATED))
        return tls_get_addr_tail (GET_ADDR_PARAM, dtv, NULL);

    return (char *) p + GET_ADDR_OFFSET;
}
```

它的输入是一个指向 GOT 中重定位条目的指针，那里存储着我们的两个重定位信息：模块 ID 和该特定变量相对于该模块 TLS 的偏移量。我想立即说明，虽然每个线程都有自己的数据，但每个线程都有自己的小块，这个偏移量对于所有线程来说是相同的，只是它们的块不同。

让我们看看它是如何工作的。

1. 第 35 行（`__tls_get_addr` 位于第 33 行）使用了一个宏 `THREAD_DTV`，它做了一件非常简单的事情：它通过 `fs` 寄存器获取第一个元素，也就是指向我们 DTV 的指针，并返回它。也就是通过线程指针，我们得到了 DTV。
2. 然后，我们从 DTV 中取出它的计数器（即代号），并与全局代号进行比较。
3. 如果它们不一致，我们会走另一条稍微不同的路径，该路径将根据新的变化（模块添加或删除）更新这个 DTV 向量。之后实际上执行的还是同样的操作，只是这里手动进行了一些尾部优化等。
4. 接着，根据我们从 GOT 中获取的模块 ID（这是加载器在加载时为我们准备好的），我们获取指向基地址的指针。这个 `pointer.val` 就是存储我们 TLS 块的基地址。
5. 检查它是否已分配，当然，因为它可能尚未分配。如果未分配，就需要分配这个 TLS，然后继续同样的路径。
6. 最后，当地址中包含了基地址（特定于我们线程的基地址）时，我们只需将同样从 GOT 中获取的偏移量加到它上面。那里会有两个连续的重定位：模块 ID 和偏移量。

原则上，这完全保证了我们能够遍历整个结构，获取基地址和偏移量，无论是在静态 TLS 还是动态 TLS 中。

```
https://godbolt.org/z/QfvmAV
```

希望到目前为止一切都清楚。让我们看看这在代码中是什么样子。为此，我们当然要使用 Compiler Explorer，非常感谢 Matt Godbolt 制作了这个绝佳的工具。

```cpp
extern thread_local int t_glob;
extern thread_local int t_glob_with_val;

void fn()
{
    t_glob++;
    t_glob_with_val += 2;
}
```

我们声明了两个 `thread_local` 变量。它们都带有 `extern` 关键词，意味着我们不知道它们具体定义在哪里。

```
_Z2fnv:                                 # @_Z2fnv
        pushq   %rax
        cmpq    $0, _ZTH6t_glob@GOTPCREL(%rip)
        jne     .LBB0_1

        # 第一条指令
        data16
        leaq    t_glob@TLSGD(%rip), %rdi

        # 第二条指令
        data16
        data16
        rex64
        callq   __tls_get_addr@PLT

        addl    $1, (%rax)
        # ...
```

我们感兴趣的是这个代码块。这里有一些指令前缀（`data16`），它们实际上是占位符，因为这是一个重型模型，静态链接器（当我们构建程序时）可能会尝试用一个更轻量、占用更多内存但指令更少、开销更小的模型来替换它。如果你想了解更多细节，可以参考 Ulrich Drepper 关于 `thread_local` 的原始论文。

这里发生了什么？相对于 `rip` 寄存器（当前执行位置的指针），我们访问数据页中的一个地址，也就是我们的 GOT。`@TLSGD` 这个小小的重定位提示告诉我们这一点。`leaq t_glob@TLSGD(%rip), %rdi` 这条指令实际上是说，我们把 GOT 中为 `t_glob` 准备的那个包含模块 ID 和偏移量的小结构体的地址，加载到 `rdi` 寄存器中。`rdi` 是函数的第一个参数。然后我们调用 `__tls_get_addr` 函数，它从这个 GOT 条目中取出模块 ID 和偏移量，并通过 `rax` 寄存器返回该线程的具体地址。接下来就是我们自己的操作，递增 `addl $1, (%rax)1`。

```
        # 接上面代码
        cmpq    $0, _ZTH15t_glob_with_val@GOTPCREL(%rip)
        jne     .LBB0_3
.LBB0_4:
        data16
        leaq    t_glob_with_val@TLSGD(%rip), %rdi
        data16
        data16
        rex64
        callq   __tls_get_addr@PLT
        addl    $2, (%rax)
        popq    %rax
        retq
```

我们可以顺便看一下，如果我们有第二条指令，对另一个变量进行递增，会发生什么。因为是另一个变量，我们同样不知道它在哪里，所以我们执行完全相同的操作。它们看起来一模一样。这里我们做了 `+= 2`。这就是结果。记住这一点，在接下来的幻灯片中我们还会用到。



## Local Dynamic (LD)

```
+--------+       +--------+
|  BIN   |       | DSO 1  |
|        |       |        |
|        |       |  [x]   |-----+
|        |       |        |     |
|        |       |  TLS   |<----+
|        |       |        |
+--------+       +--------+
```

```
https://godbolt.org/z/g3y8uW
```

```cpp
static thread_local int t_glob = 0;
static thread_local int t_glob_with_val = 5;
void fn(int& val2)
{
    t_glob++;
    t_glob_with_val += 2;
}
```

在这里我们有了更多的信息。我们同样是用 `-fpic` 编译代码，这很可能是一个共享库，但这次我们访问的是一个**本地变量**，它与访问它的代码定义在同一个目标文件中。因此，编译器有了更多数据，它至少知道它在哪里。

让我们看看如何稍微优化一下。由于它们可以存储在静态或动态存储区中，对于第一个变量，我们做的和之前完全一样。这里的占位符前缀消失了，代码变得更小、更漂亮了。我们有一个 `TLSLD` 重定位，它实际上是同一种指向 GOT 的重定位，那里存放着模块 ID，而偏移量则设为 0。我们马上会看到为什么。

```
_Z2fnRi:
        pushq   %rax
        leaq    _ZL6t_glob@TLSLD(%rip), %rdi
        callq   __tls_get_addr@PLT
        addl    $1, _ZL6t_glob@DTPOFF(%rax)
        addl    $2, _ZL15t_glob_with_val@DTPOFF(%rax)
        popq    %rax
        retq
```

我们调用 `__tls_get_addr`，它返回地址，即属于该模块的 TLS 基地址，加上零偏移。接下来会发生什么？这个地址我们可以立即用于两个本地变量。对于第一个和第二个，因为我们在这里得到了基地址（因为第二个参数偏移量为零），我们只需在这里加上我们变量的具体偏移量。编译器预先知道这些偏移量，因为它自己负责将它们布局到内存中。我们的生活稍微简化了一些。

## Initial Exec (IE)

```
+-------------------------------------------------+
|                       BIN                       |
|  +-------+   +--------+     ...     +--------+  |
|  | Obj 1 |   | Obj 2  |             | Obj N  |  |
|  |       |   |  [x]   |------------>| [Def]  |  |
|  |       |   |        |             |        |  |
|  +-------+   +--------+             +--------+  |
|                      \                          |
+-----------------------\-------------------------+
                         \
                          \
                           \
                            v
                          +--------+
                          |  DSO   |
                          | [Def]  |
                          +--------+
```

```
https://godbolt.org/z/BjW68P
```

```cpp
#include <stdio.h>

extern thread_local int t_glob;

int main(int argc, char** argv)
{
    t_glob++;
    return 0;
}
```

现在是我们的可执行对象。这里不再是 PIC 代码，事情更简单一些。但这是这样一种情况：在目标文件中，`thread_local` 变量被声明为 `extern`，我们不能完全确定它是在某个共享对象中，还是在同一个二进制文件的另一个目标文件中。也就是说，编译器有一些信息，但并不完整。

```
main:                                   # @main
        pushq   %rax
        movl    $_ZTH6t_glob, %eax
        testq   %rax, %rax
        je      .LBB0_2
        callq   _ZTH6t_glob
.LBB0_2:
        movq    t_glob@GOTTPOFF(%rip), %rax
        addl    $1, %fs:(%rax)
        xorl    %eax, %eax
        popq    %rcx
        retq
_ZTW6t_glob:                            # @_ZTW6t_glob
        pushq   %rax
        movl    $_ZTH6t_glob, %eax
        testq   %rax, %rax
        je      .LBB1_2
        callq   _ZTH6t_glob
.LBB1_2:
        movq    %fs:0, %rax
        addq    t_glob@GOTTPOFF(%rip), %rax
        popq    %rcx
        retq
```

这里使用了 `GOTTPOFF` 重定位（`R_X86_64_GOTTPOFF`）。它告诉我们，从 GOT 中获取相对于线程指针的偏移量。助记符 `GOTTPOFF`（GOT Thread Pointer）非常清晰。那里应该包含的是在 **静态 TLS** 中的偏移量，这非常重要。然后，我们从 GOT 中获取这个偏移量地址，并相对于我们的线程指针（`fs` 寄存器）得到最终地址。记住，我们的静态 TLS 位于线程指针的左侧，所以这里会得到一个负偏移量，我们用它来计算最终地址。原则上很简单。这里又有很多魔法，我们稍后也会回到这里。

## Local Exec (LE)

```
Переменные находятся локально в основном исполняемом файле
- Смещение заранее известно относительно регистра fs
- Самый дешевый доступ из всех моделей

变量在主可执行文件中是局部的
- 相对于 fs 寄存器的偏移量预先可知
- 是所有模式中成本最低的访问方式
```

```
https://godbolt.org/z/YkQUrK
```

这是我们最理想的情况。我们有一个目标文件，其中的 `thread_local` 变量与访问它的代码在同一个目标文件中声明。编译器拥有关于它位于何处、如何布局等的全部信息。

```cpp
#include <stdio.h>

static thread_local int t_glob = 0;

int main(int argc, char** argv)
{
    t_glob++;
    return 0;
}
```

```
main:                                   # @main
        addl    $1, %fs:_ZL6t_glob@TPOFF
        xorl    %eax, %eax
        retq
_ZL6t_glob:
        .long   0                       # 0x0
```

我们实际上回到了第一个代码片段。这就是我们的理想情况，`thread_local` 变量被递增，最终只变成一条命令，相对于我们的线程指针（记住是 `fs` 寄存器），在一个预先知道的地址（`t_sumvar@TPOFF`，相对于线程指针的偏移量）上操作。我想这里应该非常清楚了。

实际上有一个小的优化技巧 `-ftls-model=initial-exec`。当我们编译库时，或者只是编译一些我们仍想链接到二进制文件中的 PIC 代码时，我们可以强制要求编译器使用 `Initial Exec` 模型。这给了我们什么好处呢？我们有机会使用一个更简单的、没有额外间接寻址的模型，但同时我们失去了使用 `dlopen` 的能力，因为如果我们有动态存储，我们就无法通过这种模型访问它们。这样的应用程序将无法工作。但作为交换，我们在速度上获得了很大的提升。

## 标准讨论

那么，标准实际上是怎么说的呢？我不会强迫你们阅读所有这些文字，我试着用自己的话简单概括。

- **动态初始化**：对于块作用域的、具有静态存储期和线程存储期的变量，其动态初始化在代码控制流第一次经过其声明时进行。
- **初始化完成**：只有当它们的初始化完全结束后，才认为它们被完全初始化了。
- **异常安全**：非常重要的一点是，如果在初始化期间抛出了异常，那么这些变量被视为**未初始化**。当下次访问这些数据时，线程必须**再次尝试**初始化它们。这实际上是一个非常重要的句子，我希望我们有时间的话，会展示一些与之相关的有趣之处。
- **重入**：如果控制流在初始化期间递归地进入，则行为是**未定义**的（Undefined Behavior）。

接下来是**析构**。标准关于对象销毁是怎么说的呢？ 对于已初始化的对象，如果它们的生命周期已经开始：

- 对于**静态对象**，析构在退出 `main` 函数或调用 `std::exit` 时执行。
- 对于 **`thread_local` 对象**，其生命周期在线程退出其主函数或调用 `std::exit` 时结束。 所有 `thread_local` 变量的析构执行必须与所有静态析构函数的启动呈 **happens-before** 关系。也就是说，`thread_local` 的析构必须在静态变量（如全局变量）的析构开始之前完成。

很明显，到目前为止我们还不清楚很多事情，因为周围发生了很多魔法。让我们试着搞清楚它。

```cpp
// https://godbolt.org/z/Yh_oZ_

extern thread_local unsigned t_somevar;

void fn()
{
    t_somevar++;
}
```

我们有一个声明的变量，我们对它进行递增。

```
fn():
        pushq   %rax
        movl    $thread-local initialization routine for t_somevar, %eax
        testq   %rax, %rax
        je      .LBB0_2
        callq   thread-local initialization routine for t_somevar
.LBB0_2:
        movq    t_somevar@GOTTPOFF(%rip), %rax
        addl    $1, %fs:(%rax)
        popq    %rax
        retq
thread-local wrapper routine for t_somevar:
        pushq   %rax
        movl    $thread-local initialization routine for t_somevar, %eax
        testq   %rax, %rax
        je      .LBB1_2
        callq   thread-local initialization routine for t_somevar
.LBB1_2:
        movq    %fs:0, %rax
        addq    t_somevar@GOTTPOFF(%rip), %rax
        popq    %rcx
        retq
```


让我们看看汇编。开头有一些魔法，一些对某些符号的调用，下面也发生了一些事。在 Godbolt 中可以做什么让生活轻松一点，能更多地理解正在发生的事情呢？这里有一个很棒的功能叫“demangle”（反重整），它把名字转换成更易读的形式。我们立刻看到了一些奇怪的函数名，比如 `_ZTH...` 和 `_ZTW...`，以及对这些奇怪函数的调用。从上下文中可以理解，`init` 暗示我们应该初始化某些东西，而 `wrapper` 呢，它应该包装我们的代码。

实际上，如果你看一下主代码和开头的初始化代码，它们在 `wrapper` 中是精确重复的。`wrapper` 实际上是一个精确的副本，它返回给我们指针。

```
# -Oz
fn():
        pushq   %rax
        callq   thread-local wrapper routine for t_somevar
        incl    (%rax)
        popq    %rax
        retq
thread-local wrapper routine for t_somevar:
        pushq   %rax
        movl    $thread-local initialization routine for t_somevar, %eax
        testq   %rax, %rax
        je      .LBB1_2
        callq   thread-local initialization routine for t_somevar
.LBB1_2:
        movq    %fs:0, %rax
        addq    t_somevar@GOTTPOFF(%rip), %rax
        popq    %rcx
        retq
```


我们可以使用 Clang 的一个编译选项 `-Oz`，它能让代码更紧凑，内联更少，这会稍微简化我们的生活。我们看到开头的魔法代码消失了，只剩下对 `wrapper` 的调用。编译器最初生成了 `wrapper`，并在这里调用了它。然后，由于编译器喜欢优化，它在这里内联了 `wrapper`。所以我们既有 `wrapper` 的副本，又有内联的版本。通过 `rax` 寄存器返回了指向我们 `thread_local` 变量存储位置的指针，然后我们对它进行了递增。

但我们如何理解这个**初始化器**（initializer）是什么，如何看到它的代码呢？为此，我们稍微修改一下源代码。

```cpp
extern unsigned f();
thread_local unsigned t_somevar = f();

void fn()
{
    t_somevar++;
}
```

我们有一个 `unsigned` 变量，我们给它一个动态初始化，即通过调用一个在别处定义的函数来初始化。根据标准，当代码访问这个变量时，我们必须执行初始化器，也就是调用这个函数。

```
fn():
        pushq   %rax
        callq   thread-local initialization routine for t_somevar
        incl    %fs:t_somevar@TPOFF
        popq    %rax
        retq
thread-local wrapper routine for t_somevar:
        pushq   %rax
        callq   thread-local initialization routine for t_somevar
        movq    %fs:0, %rax
        leaq    t_somevar@TPOFF(%rax), %rax
        popq    %rcx
        retq
thread-local initialization routine for t_somevar:
        pushq   %rax
        cmpb    $0, %fs:__tls_guard@TPOFF
        je      .LBB2_1
.LBB2_2:
        popq    %rax
        retq
.LBB2_1:
        movb    $1, %fs:__tls_guard@TPOFF
        callq   f()
        movl    %eax, %fs:t_somevar@TPOFF
        jmp     .LBB2_2
t_somevar:
        .long   0                       # 0x0

__tls_guard:
        .byte   0                       # 0x0
```

现在让我们看看代码本身。这里会出现初始化器。初始化函数本身做了什么？它出现了一个额外的对象，实际上是一个 `byte` 类型的变量，它显然也是 `thread_local` 的。简单来说，这是一个布尔类型，它也是 `thread_local` 的，并且它是一个**守卫**（guard）。这有什么用？就像单例模式如何工作一样，我们有一个标志。第一次通过时，我们检查它是否为零。是的， значит 我们需要初始化对象。我们进行初始化，然后设置标志，表示一切都已初始化。下次进入时，我们只需要检查对象是否已初始化。如果已经初始化，我们什么都不用做。这个 `thread_local` 变量实际上我们在代码中是看不到的，但它确实存在。在开始时，我们检查它的值，如果已初始化，就直接返回。如果未初始化，我们接下来设置这个标志，表示“已初始化”。

然后我们调用函数本身并获取地址。但这里有一个有趣的时刻。还记得我强调过，标准中写着，如果在初始化时抛出异常，那么初始化被视为未完成，下次通过时必须重试吗？**我认为这里实际上编译器存在一个错误**。因为标志在我们调用函数**之前**就被设置为了“一切顺利”。他们很可能是想通过这种方式解决标准中被认为是未定义行为的循环问题，但他们实际上违反了标准，因为在发生异常的情况下，将不会有重复的初始化。所以，如果你要比较编译器的行为和标准，请注意，唉，就是这样。

好的，关于这段代码，我想说的就这么多了。

我们来总结一下。我们出现了两个用于 TLS 的函数：

- **`_ZTH...`** (TLS Init Function)：这是初始化函数。它们是**弱符号**。这是什么意思？如果我们使用一个在别处声明的变量，我们不知道它是否已初始化。因此，我们首先请求链接器为我们放置这个弱函数的地址。如果它找到了，它就放置我们必须调用的初始化函数的地址。如果没有，那里就是零。在包装器中，开头检查 `init_function` 的那段代码做的正是这件事：它检查我们是否有初始化函数。如果有，我们就调用它。
- **`_ZTW...`** (TLS Wrapper)：这是我们的包装器，它实际上是编译器生成的代码的来源。编译器总是保留它们，因为可能另一个目标文件是用 `-Oz` 之类的选项编译的，它会尝试寻找这些包装器，并通过它们来访问 `thread_local` 变量。

```cpp
// https://godbolt.org/z/hhaYmq

#include <stdio.h>

class SomeCls
{
public:
    SomeCls();
    ~SomeCls();

    void increment();

private:
    int m_count = 0;
};

thread_local SomeCls t_scls;

int main(int argc, char** argv)
{
        t_scls.increment();
        return 0;
}
```

让我们看一个关于对象的例子。毕竟我们 активно地使用 C++，对象在某种意义上是 C++ 的精髓。我们有一个类，它有在别处定义的构造函数和析构函数，一个相当不平凡的例子。我们有一个 `increment` 函数，它也定义在别处，并做一些事情。`thread_local` 变量在全局作用域声明。在 `main` 函数中，我们调用这个 `increment` 函数。

```
main:                                   # @main
        pushq   %rax
        callq   _ZTH6t_scls
        movq    %fs:0, %rax
        leaq    t_scls@TPOFF(%rax), %rdi
        callq   _ZN7SomeCls9incrementEv
        xorl    %eax, %eax
        popq    %rcx
        retq
_ZTW6t_scls:                            # @_ZTW6t_scls
        pushq   %rax
        callq   _ZTH6t_scls
        movq    %fs:0, %rax
        leaq    t_scls@TPOFF(%rax), %rax
        popq    %rcx
        retq
_ZTH6t_scls:                            # @_ZTH6t_scls
        pushq   %rbx
        cmpb    $0, %fs:__tls_guard@TPOFF
        je      .LBB2_2
        popq    %rbx
        retq
.LBB2_2:
        movb    $1, %fs:__tls_guard@TPOFF
        movq    %fs:0, %rax
        leaq    t_scls@TPOFF(%rax), %rbx
        movq    %rbx, %rdi
        callq   _ZN7SomeClsC1Ev
        movl    $_ZN7SomeClsD1Ev, %edi
        movl    $__dso_handle, %edx
        movq    %rbx, %rsi
        popq    %rbx
        jmp     __cxa_thread_atexit     # TAILCALL
t_scls:
        .zero   4

__tls_guard:
        .byte   0                       # 0x0
```

在开始时，初始化器被调用，我们像往常一样检查守卫。如果需要初始化，我们再次举起我们的守卫旗帜，表示“我们正在初始化”（尽管事实并非如此）。然后我们做同样的事情，获取我们 `thread_local` 变量的地址。接下来我们意识到，在这种情况下，我们的 `thread_local` 变量是一个对象，指向它的指针实际上就是 `this`。然后我们将参数传递给一个有趣的函数：`__cxa_thread_atexit`。我们基本上都知道 `atexit` 函数，如果我们希望在程序终止时调用一些回调，我们就注册它们。我们有一个相应的函数，它会为我们清理析构函数。也就是说，它们的调用顺序与它们在代码执行过程中被注册的顺序相反。当线程退出时，它们都会被依次调用。

这是如何发生的呢？在一个特定的、用于 `exit` 的栈中，我们**注册析构函数**，注册我们的 `this` 指针，以及一个非常重要的东西——**DSO 句柄**，这是它所在特定模块的标识符。这很重要，因为动态对象也可能单独离开。然后我们将所有这些（实际上是通过寄存器）传递给一个函数，该函数将它们注册到栈上。当我们的线程主函数退出时，所有这些析构函数都会带着它们的 `this` 指针被依次调用。

- 对象在第一次访问时初始化，就像动态初始化一样。
- 为对象创建了额外的守卫。
- 对于对象，会额外调用 `__cxa_thread_atexit` 来注册其析构函数。

还有一个重要的规则源自标准：我们不应有意或无意地混合静态对象和 `thread_local` 对象的析构。例如，我们有一些全局对象，它们的析构函数使用了某些 `thread_local` 对象。这种情况只可能在一种情况下发生：如果你所有的 `thread_local` 对象已经被销毁了，因为它们是 `sequence-before` 的。如果你在这种时候访问 `thread_local` 变量，起初一切都会很好，它会被调用，一切正常，它的析构函数也会被放入那个美妙的栈中，**但将没有东西去调用它**。因为线程本身已经被销毁了，我们不能指望析构函数会被调用。它就是不会被调用，这完全符合标准，即未定义行为。

那么，接下来呢？上面说的是经典模型，我们看到它在各种复杂情况下有很多不理想之处。编译器开发者自然开始思考可以做些什么。这里有一篇 **Alexandre Oliva** 的论文，我推荐阅读，如果你想让大脑骨折的话，因为里面描述得相当复杂。如果你想先看简单点的，可以在 Android 文档中找到一个更直观地展示所有这些想法的文档。

这种所谓的**描述符模型**（Descriptor Model）的意义何在？我们可以用一种稍微不同的方式使用 GOT。我们可以把某种函数式编程的思想应用进来。我们可以在 GOT 中与我们对象对应的第一个条目里，放置一个**解析器函数**（resolver），这个函数可以根据我们处理的情况而改变。下一个条目是它的一个参数。这个解析器函数根据参数输出 `thread_local` 变量的地址。我们需要理解的是，当进行动态加载时，动态加载器对它所加载的代码有更多的了解：动态对象在哪里，它们的存储区在哪里，它们是在静态 TLS 中还是动态 TLS 中，以及可以对它们做什么。

它是如何工作的呢？自然，我们有自己的重定位类型，`TLS_DTPREL`。它看起来就像开头那个结构体，包含一个解析器的地址和一个传递给解析器的参数。解析器将在程序加载时由链接器设置，它会根据情况选择对你来说开销最小的方案。工作方式绝对简单：通过重定位获取 GOT 中描述符的地址，调用解析器本身，然后将结果与我们的 TLS 指针（即 `fs` 寄存器）相加。

下面是一个解析器的例子，当 `thread_local` 变量的偏移量是预先知道的时。链接器会做什么？它会放置这个最简单的解析器，它只返回传递给它的参数。它会给它一个指向结构的指针，从中获取这个参数。它实际上立即就返回了我们需要的指针。非常简单和容易。

需要马上说明的是，这些解析器有非标准的 ABI。它们通过 `rax` 寄存器接收唯一的第一个参数——指向 GOT 的指针（在 x86-64 上通常是 `rdi`）。它们这样做是为了节省寄存器。我们可以使用 `-mtls-dialect` 关键词来尝试这个。它已经在 GCC 中完全实现，但不幸的是，在 Clang 中目前只有 ARM64 的支持。但我们现在可以在 GCC 中看到它。

让我们看一个代码片段。这是我们那个简单的例子，一个 `thread_local` 变量在某处定义，我们对它进行递增。

我们得到了一个指向 GOT 中当前指针的指针，其偏移量相对于当前执行指针是预先知道的。这成为解析器输入函数的参数。同时，相对于当前代码位置，我们也知道被调用的函数（解析器）在 GOT 中的位置。我们获取这个解析器，这是整个描述符的指针，它在 `rax` 中返回一个相对于我们基址的偏移量地址。现在，知道了我们的基址，即我们正在使用的线程指针，我们就可以得到具体的值。实际上，这里可能有相当狡猾的解析器，在最坏的情况下，它们可能再次调用 `__tls_get_addr`，如果我们使用的是通过 `dlopen` 加载的、拥有自己动态 TLS 且不在静态 TLS 中的库。如果它在加载时位于静态 TLS 中，这里会有一个更廉价的、不同的解析器。

这种实现真正有趣的地方在于，我们可以在**数据层面实现懒加载**（lazy binding）。这在很大程度上是第一次。通常，当链接器加载时，它会预先链接数据，而函数则是懒加载链接的。这里我们可以对 `thread_local` 变量进行懒加载链接。当然，那里会出现并发问题，有一些使用假解析器和条件变量的技巧，非常巧妙。有兴趣的人可以去看看 glibc 的源代码，那将是非常有趣的读物。

我认为这个模型最有前途。希望它能尽快登陆 x86，并解决一些性能上的痛点。



## 基准测试



我在这里使用 Docker，因为我的机器是 Mac，但原则上，我已经在真机上验证过这些比率，它们基本是一样的。基准测试非常简单：都是递增操作。作为对比，我使用了静态变量，以及一个 `Initial Exec` 模型的变量。这里的区别仅仅在于它们的定义位置。然后是我们的经典 `pthread`，一种情况我们测量 `get_specific` 的速度，另一种情况就像我们先 `get_specific`，递增变量，然后再 `set_specific`。在 DSO 中也是同样的代码。

我们编译代码，一切链接正常，然后运行基准测试。

我们主要的参考参数是**静态全局变量**，它的访问时间是 2.94（单位任意）。然后 `Initial Exec` 不知为何稍微便宜一些，但这实际上是因为我没能让 Clang 不做循环不变量代码外提，所以对 GOT 的访问被移出了循环，我们没能测量到它。接下来是 `Local Exec`，稍微贵一点，但在误差范围内。可以说，当它在二进制文件中时，它与访问静态数据的开销大致相当。接下来自然是 `Local Dynamic`，这是动态库更便宜的模型。最重的当然是 `General Dynamic`。更不用说 `pthread_get_specific`（只取值）和 `pthread_get/set_specific`（取值、递增、设值）了，后者是最重的。

我们可以看到，原则上我们已经获得了很大的好处。我想立即说明，对这些基准测试要非常小心，因为我们当然不会持续地访问 `thread_local`。在这种情况下，我们的分支预测器已经完全学习了模式，它的预测表（PHT、BHT 等）几乎是 100% 命中，缓存也是热的。如果我们的 `thread_local` 访问是稀疏的，我们很可能两者都没有。这里很可能需要加上某个乘数，来展示更接近真实的相对计算复杂度。但在真机上，比率大致相同。



## 结论



我们今天看到了什么？

- 我们的 `pthread` 系列函数，它们可能已经过时了，但实际上仍在使用，甚至在我们抛出异常时，这个机制也在被使用。
- `thread_local` 是一个相当高效的机制，但它仍在发展。你看，并非所有架构都实现了所有这些可能的变体，尤其是在动态库方面。
- 我想总结一下，`thread_local` 的位置在哪里？实际上，`thread_local` 是一种**代码耦合机制**，就像它的近亲——全局变量一样。我们使用越多的 `thread_local`，代码的耦合就越紧密。我们都知道，拥有解耦的代码总是好的，即有独立的组件和类，它们执行自己狭窄的特定任务，它们彼此了解得越少，我们的代码就越易于维护和高效。但代码不能悬在空中，因此我们需要一些耦合机制。
- 所以对我个人而言，我得出的结论是：`thread_local` 是一种耦合机制。它应该位于其适当的节点上，为我们提供比全局对象和变量更轻量级的耦合方式。我认为这才是它的正确位置。我不建议滥用 `thread_local`，它们有自己的“栖息地”，在那里它们非常好用。

我为大家收集了一些有用的链接和文章。我想对于那些想更深入地了解这个主题、了解更多细节的人来说，这里的资料集足够让你深入研究这个主题了，你甚至可能会挖掘出一些额外的信息，那里真的有很多有趣的细节值得探索。

在此，我想表示感谢，并为一些小的技术问题道歉。这里是我的联系方式，我随时准备提供帮助，回答任何问题。所以，欢迎大家。
