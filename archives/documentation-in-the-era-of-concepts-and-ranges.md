# concept 和 std::ranges 时代的文档

标题：Documentation in the Era of Concepts and Ranges

日期：2021/12/23

作者：Christopher Di Bella & Sy Brand

链接：[https://www.youtube.com/watch?v=nm45t2fnUms](https://www.youtube.com/watch?v=nm45t2fnUms)

注意：此为 **AI 翻译生成** 的中文转录稿，详细说明请参阅仓库中的 [README](/README.md) 文件。

备注：`std::ranges` 本身是高强度使用 `concept` 自文档化的，所以挑了一个解说视频。

-------

大家好，我是Christopher Di Bella，谷歌的软件工程师。我叫Sy Brand，我是微软的C++开发者布道师。今天，我们将和大家谈谈概念（`concept`）和范围（`std::ranges`）时代的文档。

所以，我去Twitter上找我为了激励这次演讲而发的推文，结果找到了这条。我喜欢在会议演讲开始时放一条我在构思演讲时发的推文，但我没有一条合适的，所以我发了这条推文，这样我就有东西可以放在我CppCon演讲的开头了。现在，我们就在CppCon的演讲现场了。

但说真的，这一切背后的动机是：概念如何影响我们的C++文档？我们将从多个不同的角度来讨论这个问题。

我们首先会从现状开始。C++项目今天在他们的文档中做什么？然后我们将继续讨论什么是好的文档？是什么让文档变得优秀且适合其目的？接着，概念如何与文档交互？在这里，我们指的是C++20概念。然后我们将特别看看范围，对它们做一个案例分析。即C++20范围。最后，我们将探讨未来我们应该如何改变记录C++代码的方式。

在我们进入实际内容之前，我们应该先说明一点：我们在这里所说的一切都是我们自己的观点，并不代表我们的雇主。我们确实对现有库提出了一些批评。我们认为它们很棒，但批评是出于善意。当我们谈论这类事情时，我们是希望改进现状，而不是抨击任何现有的内容。

那么，让我们从讨论存在哪些不同类型的文档开始。我们有四大类文档，从设计开始，它详细说明了你所设计的东西。我们有实现类的东西，比如注释、内部API和外部API。在这次演讲中，我们主要关注内部API和外部API，但很多主题可以超越这些范畴，与所有四个文档领域都相关。

然后，如果我们再细分一点，我们可以看到还有四种文档。这现在更侧重于用户可能想要什么。我们有面向学习的教程，用户零知识，我们想让他们达到能使用的状态。我们有面向目标的教程、操作指南，这些真正帮助人们从他们现在的某个位置出发。他们已经知道自己想要达到什么目标，但不知道如何到达那里。面向目标的操作指南将引导他们从A点到达B点。我们有面向理解的讨论，真正阐明某些决策背后的意义和作者的理由。然后是面向信息的参考资料，这有点像你API的百科全书。它涵盖了所有不太适合前三类的内容。

关于这类东西，有大量的信息需要理解。我们在这里主要讨论的是面向信息的参考资料，但我们将要讨论的很多内容也适用于其他三类。如果你想了解更多关于这类东西的信息，你一定要去看看“Write the Docs”大会（write the docs conference），它涵盖了所有这些内容，其详细程度远超我们在一小时内可能做到的。

好的。那么让我们继续讨论现状。我们今天处于什么位置？C++项目现在用他们的文档做什么？

因此，我们将看几个例子，其中一些你可能听说过。一个是来自谷歌的Abseil，这是一个非常流行的库。这是他们用于拆分字符串的`str_split`函数的一些文档。现在，关于这个文档需要注意的一点是，在整个库的文档中，它都非常依赖于散文和示例。它不太倾向于采用那种逐个分解函数签名、查看每个参数含义等方式。它主要由这些英文描述和这些示例驱动，试图让观众从文档中准确提取他们需要完成工作的信息。

这是从一个Markdown文件生成的。它是手写的文档。这不是从头文件或类似的东西中提取出来的。但头文件中也有文档，它与网页上的内容非常相似，但不完全相同。所以这是一种分离的文档。你在头文件中有为那些直接在代码上工作的人准备的东西。然后你还有为那些查看网页的人准备的文档，这两者是分开维护的。

另一个例子是`{fmt}`库，这是一个类型安全的、类似Python风格的字符串格式化库，它影响了我们在C++20中获得的`std::format`。它采用的方法是：我们先从一个概述开始。你知道，为什么我们需要这个库？为什么我们应该使用它？用户怎么说？然后是一个快速入门指南，告诉你如何开始使用。接着它转向更熟悉的API文档。但同样，它在顶部采用了类似散文驱动的方法。我们有一些示例，它并没有像Doxygen生成的那种文档那样为每个函数签名留出大量空间。但我真的、真的很喜欢这种文档的风格。我们稍后会看看我为什么喜欢它。

这实际上是使用了Doxygen，但也使用了其他东西。这个RST是reStructuredText。这个RST是通过Doxygen从头文件中提取出来的，然后它被导入到名为Sphinx的工具中，这是Python社区制作的文档工具。我真的、真的很喜欢Sphinx。它很棒。它看起来有点像这样。你有一些reStructuredText，描述系统错误。然后在Sphinx和Doxygen之间有一个桥梁，允许你导入从Doxygen提取的文档，并将其转换为Sphinx文档。我相当喜欢这种风格。

然后我们有像LLVM这样的东西，它更像你可能习惯的经典Doxygen文档。我在这里举了一个不太公平的例子，但只是因为我们稍后会稍微批评一下。LLVM的一些文档非常棒。这部分相当简略。Doxygen倾向于采用这样的方法：每个函数都有自己的条目，这些条目是超链接的。然后它们被赋予大块的区域，你可以在其中查看它们的参数、链接回源代码、查找引用等等。尽管这里现在没有很多信息，但为每一个都留出了很多空间。

然后我们有像Catch2这样的库，它真正成功地落实了我们之前谈到的操作指南。这里的内容讨论了`CHECK`和`REQUIRE`是什么，以及如何编写一个简单的测试。它通过Markdown来完成。它完全是散文写的，带有示例，和Abseil一样，除了告诉你为了使用我们的API需要什么之外，绝对不再关注接口本身。然后他们有一个很棒的迁移文档，真正告诉你如何从Catch2 v2的现状迁移到Catch2 v3。它真正带你了解所有必要的步骤，以便从使用库的版本二迁移到版本三。

现在，如果一场名为“概念和范围时代的文档”的演讲，连几个范围库及其文档都不讨论，那就不是一场很好的演讲。

所以我们要看的第一个是Boost Range 2.0，它是Range v3的前身，而Range v3又是我们现在标准库中内容的前身。Boost Range 2.0的文档混合得非常好。它提供用法并让人们理解他们将要面对什么，并将这与理解作者关于诸如为什么他们喜欢管道操作符等事情的动机混合在一起。

我们也可以看看Range v3的文档，看到它开头非常有力，很好地概述了范围是什么，就像Boost Range 2.0一样。然后它有非常简略的参考资料，它并没有真正涵盖很多东西。我们会稍后更详细地分析这一点，但这大致就是内容的样子。原因是它像我们之前看的LLVM文档一样，是由Doxygen驱动的。这就是它的样子。我们可以看到有`\addtogroup`和Doxygen的`\precondition`指令。

但Range v3也有一些有趣的文档。例如，如果你曾经使用过Range v3并犯了错误，你可能注意到你会收到很多信息。你会从编译器收到很多模板诊断信息。如果你去查看你得到的诊断信息，你会看到偶尔会有这个全大写的“READ THIS”。因此，作者们想出的办法是，他们可以利用编译器向公众提供帮助信息的方式。并且因为这捕获了整行，包括注释部分的文本，他们可以对用户说：嘿，去阅读头文件里的这个东西。然后你就能看到这段漂亮的散文式文档，上面写着：当管道连接一个范围适配器（range adapter）时，你需要满足可视图范围（viewable range）概念的要求。然后它继续以更易于理解的方式解释这意味着什么。

此外，Range v3有很棒的测试，有一个很棒的测试框架，这也作为文档。它可能是库中最好的文档形式，而且非常全面。例如，这个我从`chunk_view`测试中摘取的`chunk_view`示例，一旦你掌握了词汇，你就能很快看出这个特定的范围将是一个随机访问范围（random access range），它将内容分组为大小为三的块（chunks），然后继续。当不再有三个元素的组时，它就直接把剩下的东西给我们。

所以这大致就是现状的样子。那么现在我们要做的是，我们将专注于好的文档。那么什么是好的文档？

所以我为此查阅了许多不同的资料，这些是我反复看到的主要方面。我们将逐一分解所有这些，它们是：适合上下文、清晰、易于消化、完整、可访问和及时更新。

所以让我们逐一过一遍这些。你知道，当我说适合上下文时，我真正的意思是什么？如果我们回顾几页幻灯片之前，我们说，你知道，有哪些类型的文档：设计、实现、操作指南、参考资料。这些都是——其中一些针对不同的受众，对吧？比如，不在你库上工作的人很可能不需要实现文档，但在上面工作的人需要。初学者和专家在你的文档中可能也想要不同类型的文档。你需要考虑你的受众是谁。你需要考虑谁在消费你的文档，他们需要什么。所以这是我们这次演讲的第一个关键点：了解你的受众，了解你为谁编写文档。明确地思考它，并决定你为谁写作以及如何最好地针对该受众。

我们看到一个关于cppreference上`std::ranges`条目的问题，我们稍后肯定会讨论这个。

那么，关于清晰，Chris？清晰性真正意味着你如何将信息传达给用户，他们能否弄清楚你在谈论什么？让我们回到Catch2，例如，Catch2在其用户最先阅读的文档中提出了一个问题：为什么我们需要又一个C++测试框架？然后它继续谈论，你知道，我们有所有这些其他的测试框架。Catch2带来了什么，为什么我们在一片已经过度拥挤的测试框架海洋中还需要一个全新的库？它通过使用项目符号列表和优点来分解这一点，并真正强调关键特性是什么，以及它将其他库可能没有做或没有作为一个整体做的事情整合在一起。所以当你离开这个文档时，你会有一个清晰的概念，你能够回忆起Catch2带来了什么，而其他库可能没有做，或者可能没有作为一个集体来做。

然后我们有用户指南，即初始教程，它非常清晰，因为它所做的就是让人们做事情，这使得你需要跟随操作这一点非常清晰。它鼓励你做他们正在做的事情，真正地手把手教你，让你达到一个能使用这个库作为你的测试框架的功能状态。

然后如果我们回到自然表达式（natural expressions）页面，它只讨论`CATCH`（不，是`CHECK`和`REQUIRE`）表达式，以及它们的含义和为什么你想使用它们。所以它不仅告诉你“是什么”，还告诉你“为什么”和“如何”，并且在一定程度上为不同的受众分开做这件事，这又回到了我刚才谈到的观点，即在你开始与他们沟通之前，你需要了解你的受众。这样他们才能理解你想告诉他们关于你的库的内容。

那么让我们谈谈可消化性，我们会引用一些我们已经看过的例子。我们看了LLVM。这里的可消化性，你知道，有几个方面。我认为这里的Doxygen非常清晰地划分了所有这些不同的部分，这确实有助于你，你知道，快速浏览列表并找出你在寻找什么。它为这些部分留出了很多空间，这可能使它不那么容易消化，但它们也提供了很多超链接来帮助你跳转等等。所以我们思考的是，你知道，某人应该如何阅读和理解这个？它会不会只是一堵巨大的文字墙？它会有超链接吗？我是否给它划分了清晰的部分？诸如此类的事情，思考你文档的层次结构以及如何使它更易于消化。

再次，我认为`{fmt}`库在这里做得非常出色。这些是清晰划分的部分，但它没有浪费太多空间。扫描这个相当容易，而且也很容易理解你在哪里、你在看什么以及你在寻找什么。我也很喜欢它，你知道，它分开了。它有散文，有签名，有示例。这非常棒。对我来说，阅读这个文档非常愉快。

这些库采用了稍微不同的方法，它们可能各有优缺点。在这个演讲中，我们不会告诉你为你的文档使用什么工具。我个人认为，我真的很喜欢Sphinx和手写文档。我认为它确实比那种自动生成的东西更能帮助用户。但我们希望你们做的是考虑可用的工具，并利用它们来最大化你的文档质量。不要教条化。在了解你的受众的基础上，决定什么工具适合你和你想告诉用户的内容，然后使用它们来最大化你的文档质量。我们也在讨论，你知道，是什么构成了高质量的文档。所以在前进的过程中请记住这一点。

还有完整性的问题，并不是要贬低这个LLVM的东西，但你知道，这并不完整。这里缺少很多信息。如果我想调用这个`LLVMGetBitcodeModule2`，我缺少很多信息。也许我知道这个是因为我已经了解LLVM的其他部分，我知道，哦，它可能需要像这样设置内存缓冲区，这个模块引用应该来自另一个地方。但是，你知道，这对用户要求很高。这里可能缺少很多信息。

然后，一旦你有了完整的文档，你真的需要考虑可访问性。可访问性有两个不同的维度。我们将依次考虑它们。

让我们举一个在C++中拆分字符串的例子，因为我们讨论过Abseil有一个`string_split`。现在，在C++中还有其他流行的拆分字符串的方法。那么让我们上网搜索一下“how to split a string in C++”。这是网页搜索的第一页，没有流行的方法被提及。没有关于标准拆分的内容。没有关于Abseil的`split`、Boost的`split`或其他任何在这个问题上真正流行的库的内容。有很多关于如何拆分字符串的问题，但不一定涉及有哪些常规方法。

幸运的是，C++20引入了一种方法来做这件事。所以我们将直接跳到cppreference，看看C++20给我们的`split_view`。假设我们还不知道如何使用这个库。我们遇到了一个接口，这描述性不强，而且有很多文字。所以让我们向下滚动。我们想再往下滚动一点。我们想现在滚动到……好吧，我们得滚动几次。我想我们滚动四次才看到那个示例，它展示了我们需要做什么来拆分一个字符串。

所以这里可访问性的概念是，某些东西需要易于找到，并且易于让你的受众理解发生了什么。cppreference的受众非常广泛。它不仅迎合初学者，也迎合那些只需要查找少量信息就继续的专家。但这些信息可能没有以对所有人都可访问的方式组织。它首先关注接口，这使得已经知道自己要找什么的人容易上手，而把初学者推到了最后，因为他们需要向下滚动到最后。

所以这是可访问性的第一个维度：确保你的受众能够访问那些确实适合他们的信息。

第二个维度是面向人的可访问性。现在，并非每个人都会像我们一样，所以我们需要确保我们编写的文档能够迎合尽可能广泛的受众。这意味着我们需要考虑一些事情，比如拥有文本，这样屏幕阅读器可以获取内容，而不是使用图像。而且，你知道，这不仅意味着屏幕阅读器，我们还可以在不破坏分辨率的情况下增大字体。如果图像绝对必要，那么我们应该考虑提供替代文本，这样屏幕阅读器才能理解图像应该显示什么。

现在，我们不会深入讨论这个，因为这是一个非常复杂的话题，我们在这个演讲中没有足够的带宽来真正花时间讨论它。它本身就可以占用一整场演讲。所以我们将把可访问性指南推迟到“Write the Docs”大会，在那里你可以学到更多，并且他们为这个特定的可访问性维度提供了适当的时间。

最后，我们有文档——好的文档应该是及时更新的。

现在，如果我们回到Abseil的例子，你会记得Sy提到Abseil有一个可以在网上找到的基于散文的文档。然后在头文件中也有基于注释的文档，你可以在`str_split`的头文件中找到。这是我们俩都非常喜欢的东西，我们稍后会解释为什么，但这确实需要相当高的警惕性，因为可能有人决定为Abseil做贡献。他们可能以某种方式去更新接口。然后他们看到文档在头文件中。所以头文件被更新了。他们没有意识到网页文档不是从头文件文档自动生成的——不像`{fmt}`库那样。这是两个需要维护的独立事物。于是负担就落在了维护者身上。如果维护者没有注意，他们批准了它并合并到了主分支，那么文档现在就不同步了，因为基于代码的文档是正确的，而基于网页的文档突然变得过时了。过时的文档比无用更糟糕，因为它让人对接口产生错误的理解。

所以，尽管我们是这种多模式文档的粉丝，但你需要确保你所有的文档都是最新的，才能被认为是好的文档。

现在，我们喜欢这种多模式文档的原因是它迎合了不同的受众。几周前我们做了一个关于用户喜欢看到什么的调查，我们可以看到绝大多数人希望有外部文档。那个绝大多数中的一小部分人也希望有内部文档。我们将外部文档定义为可以在网上找到的、易于查阅的东西。而内部文档指的是头文件中基于注释的东西。所以不同的受众想要不同的东西，但几乎每个人都希望有外部文档可用。

所以我们真正想说的是，你应该在多个维度上衡量你的文档。这意味着你要确保你的文档将能触及尽可能广泛的受众，并且它永远不会过时。你要确保它迎合尽可能多的人，并且始终保持最新。

所以这就是好的文档。思考在多个维度上衡量你的文档质量，所有我们刚才讨论过的维度。

现在我们将继续讨论概念如何与文档交互。

那么，Chris，什么是概念？概念表达了某种算法的要求，这些要求分为三种：语法要求、语义要求和复杂度要求。我们说一个类型建模了一个概念，如果它满足我们刚才讨论的所有要求。

让我们以`size_range`概念为例。我们有一个类型`R`和该类型的一个对象。在`R`上的`size_range`概念，我们说它记录了`R`是一个范围。这意味着我们可以在`R`上调用`ranges::begin`和在`R`上调用`ranges::end`。然后我们还需要能够在`R`上调用`ranges::size`。当我们调用`ranges::size`时，它会以均摊常数时间返回`R`拥有的元素数量，并且`ranges::size`不会修改`R`。此外，如果`R`建模了`forward_range`概念，那么`ranges::size`将总是可用的。

那么让我们看一个概念如何与文档交互的例子。让我们考虑这个函数`register_callback`。这是一个接受某个类型的对象`F`的函数。关于这个类型`F`我们知道什么？嗯，也许我们可以凭直觉推断，因为它叫`register_callback`，类型叫`F`，那么它是某种函数，这可能是合理的猜测，但我们对此了解不多。

如果我们想告诉用户关于这个函数的信息，我们可以给他们提供一些文档。比如说，你必须传递一个接受`void*`的回调。假设我们用它来传递给C API之类的东西。但现在我们没有这个文档。我们只有`register_callback`某个函数。

假设我们传递了一个接受`int`而不是`void*`的闭包。现在会发生什么？嗯，我们的编译器会对我们大喊大叫，对吧？我们得到一个编译器错误，我们需要做一点侦探工作来弄清楚这意味着什么。你可以在底部看出来，你知道，它写着`cannot convert void* to int for first argument`。所以你大概能弄清楚我们传递了某个期望`int`的东西，而它想要接受`void*`的东西。

我们再想一下。如果我们用概念来装饰`register_callback`会怎么样？现在这个`std::invocable`说`f`是某种类型，其实例可以用`void*`的实例来调用。所以它可以是函数指针、闭包、函数对象，任何你可以用`void*`调用或调用的东西。

所以这既是给用户的文档，也是给编译器的文档，对吧？如果我们看这个，并且我们知道`std::invocable`是什么意思，那么这就成为了我和这个库的实现者之间、其他用户和编译器之间、每个人之间的共享词汇。

这也在编译器错误中反映出来。这是来自Clang的。Clang说，如果我们做同样的事情，传递一个接受`int`而不是`void*`的东西，它会说：

```
candidate template ignored: constraints not satisfied because 'std::invocable<our_lambda, void*>' evaluated to false
```

我认为这是一个相当清晰的编译器错误。

所以我们开始认为概念既是在与用户沟通，也是在和编译器沟通。

让我们看一个稍微复杂一点的例子。假设我们有一个叫`cartesian_product`的函数，它接受一堆范围并返回表示它们笛卡尔积的东西。它对我们的`Vs...`有更复杂的约束。我们所有的`Vs`必须是可视图范围。这是我们为了让它成为我们和用户以及编译器之间的共享词汇所需要理解的东西。但一旦我们理解了一个可视图范围是那种要么不拥有其元素、一个范围视图适配器），要么它可能是一个左值的东西——所以它不会拥有一些会在某个时刻超出作用域的内存——那么它将是一个可视图范围。

一旦我们理解了这一点，我们就知道我们在要求什么。它还要求所有`Vs`都是前向范围，并且我们至少传递一个范围。一旦我们理解了这些，我们作为用户就理解了我们在谈论什么。编译器也理解了。

如果我们做类似传递一个右值`vector`给这个`cartesian_product`的事情，一个右值`vector`不是一个可视图范围。它会超出作用域。所以我们得到编译器错误。它说：

```
constraints not satisfied because std::vector<int> does not satisfy viewable_range
```

所以我们真正想说的是，概念是一种工具，你可以用它来同时向用户和编译器表达约束。所以当我们说我们希望你们使用可用的工具来最大化文档质量时——就像我们之前谈论Doxygen、Sphinx之类的东西时——概念可以被用作一种文档工具。

当我们从谈论概念如何与文档交互转向我们的案例研究——即C++20范围时，我们将很快对此进行扩展。

那么，Chris，什么是范围？范围本质上是一个类型，它允许我们遍历某个数据结构中的元素。范围由一个迭代器表示，它指向我们称之为范围的第一个元素，然后是一个哨位，它描述了结束范围的规则。

我们在C++中描述范围类型的方式是，我们可以对范围调用`ranges::begin`，它会返回给我们迭代器。然后我们可以对该对象调用`ranges::end`，它会返回给我们表示结束规则的哨位。

我们有不同种类的范围，这些不同的范围提供不同的功能。我们已经看到大小范围是一个范围，它还允许我们在范围对象上调用`ranges::size`。但我们也有像随机访问范围这样的东西，它们被要求拥有一个随机访问迭代器作为指向第一个元素的迭代器。因为这意味着我们可以做一些花哨的事情，比如能够任意跳过一定数量的元素，而不必一个接一个地顺序遍历它们。这意味着我们可以在常数时间内从点A跳到点B。

一旦我们知道了这类东西，我们就可以思考我们应该如何记录范围。

现在，这里有一点背景故事。去年，我被要求在COVID期间担任一所大学的志愿讲师，那是一个C++ 101课程，学生已经有两年先前的编程经验。我想在那个课程中教授范围，并意识到cppreference在范围方面的文档不多。所以我最终做的是，我去看了看C++98/03/11/14/17算法是如何被记录的，并用它作为我记录基于范围的算法的基础。这就是我最终得到的东西。

是的，我昨晚把这个给一个朋友看了，他们说他们这辈子没见过这么多冒号。所以我有点担心我去年碰巧开始的这个文档不符合我们的指导方针。你觉得呢？

嗯，从技术上讲，我们确实说过概念是一种文档工具。所以，我想这没问题。

好的。那么，如果我在这里转述你的话，你的意思是概念可以用作文档工具，但像任何其他文档工具一样，它们也可能被误用。这意味着概念也可能被误用。所以这基本上意味着，仅仅因为我们说概念可以是一种文档工具，这并不意味着你应该开始在每样东西上都扔概念来记录东西，因为这最终会混淆文档，使它非常令人生畏去阅读。

这是否回答了之前的问题？我想我们现在会回答之前的问题。这应该是什么样子？让我们想想这个应该是什么样子。Chris，你有什么建议吗？

是的。经过一番思考，我想到把这个`transform`的例子放到最顶部，把API放到最底部。我们之前讨论过可访问性，以及初学者必须滚动浏览很多东西。滚动浏览那个`split_view`远没有这个`transform`例子那么困难。所以我们在这里所做的是，我们把例子转置到了最顶部，把API放到了下面的一个部分，并明确地标明它是API。

你觉得这个和之前的相比怎么样？我认为这绝对是一个改进。我认为，为了绝对的清晰度并确保它适合其目的，我们缺少的是对这个东西实际是什么的描述。你知道，我们有点假设有人来这里是知道他们想做什么的。我们没有关于`std::ranges::transform`实际上做什么的任何高层解释。对吧？

那么，如果我们采纳你所说的，应用到cppreference上。我们把描述放在顶部，解释`ranges::transform`应该做什么，用户能从中期待什么。还有我在编辑时意识到的一点，我特别喜欢做的事情是不记得东西属于哪个头文件。我非常依赖cppreference来查找东西属于哪个头文件。而且因为它字体很小，并且不会妨碍其他任何东西，我想到把定义这些东西的头文件也放回最顶部。然后是描述，用大得多的字体，这样能吸引人们的注意力。但那些不想记东西、只想图方便的人仍然可以与之交互。所以我认为这兼顾了两者的优点，同时迎合了两个受众。Sy，你觉得这个怎么样？

我确实认为这是一个巨大的改进，甚至没有真正改变页面的内容。只是再次思考了我们的受众，思考了人们访问这个页面是为了寻找什么。这是一个巨大的改进。你知道，我们思考了我们的部分。我们组织了我们的信息，思考了我们的受众，思考了让它易于消化、清晰、可理解。我们了解了我们的受众，对吧？我们整个过程中都在思考受众。

所以我认为这在某种程度上回答了最初的那个问题。我认为，即使只是重组这些信息也能带来巨大的改变。但接下来我们也要思考如何能以稍微不同的方式使用概念来记录文档。

有一个问题是：我的范围可以是const的吗？就像Chris说的，我们有很多不同种类的范围。如果我有一个范围，我可以const限定它然后遍历它的成员吗？这在某些范围中是可行的，而其他范围不支持。那么我们怎么知道呢？嗯，我们想查看文档看看这是否被支持，对吧？

假设我们去cppreference，想知道我们的`join_view`是否可以是const可迭代的。好的，首先我们需要知道的是，我们需要检查`join_view`的`begin`和`end`成员函数。所以让我们向下滚动，然后打开`begin`和`end`的子页面，再看看那些签名。然后我们需要知道我们需要检查`begin`和`end`的const限定版本。知道了这些，我们就能推断出我们的`join_view`是const可迭代的，只要我们的底层范围的const版本是一个输入范围并且它的引用类型是一个真正的引用，即不是一个代理。所以我们算是找到了答案。但这要求我已经具备一堆领域知识。它需要一点侦探工作。

也许有处理这个问题的不同方法。也许还有其他类似的问题我们可能会想问。你能想到任何吗，Chris？抱歉，你能重复一下吗，Sy？ 是的，我们可能会问的另一个问题是什么？哦，对了。我想到的一件事是：我们能将`range.begin()`和`range.end()`传递给一个经典算法吗？我们之前谈过，范围是有迭代器和表示结束的哨位的东西。但在C++98中，我们有一个范围，它有一个指向开头的迭代器，然后是一个指向最后一个元素之后的第二个迭代器来表示范围的结束。这就是我们所说的公共范围。所以它是一个特殊类别的范围。像`vector`这样的东西就是一个公共范围，因为它有一对迭代器，而不是一个迭代器和一个不同的哨位类型。

你可能会想，嗯，如果我们使用范围，为什么我们要使用C++98算法？也许有人写了一个在C++98时代一直到17的库，他们还没有来得及使用基于哨位的算法。所以这就是我们在这里考虑的那种问题。为了使用这种风格的算法，我们需要一个公共范围。

那么让我们看看`lazy_split_view`，看看这是否是一个公共范围。事实证明，如果我们的结束位置满足范围是前向范围并且是公共范围，那么在我们的`lazy_split_view`中我们就有一个公共范围。但是，虽然这在一定程度上由第一个重载暗示了，但我们确实需要查看pros文档。那还不算太糟，但第二个重载才是我们真正需要关注的，因为它的接口完全没有上下文。然后我们需要去看pros，我们看到它返回一个外部迭代器或默认哨位，取决于某些要求。我们必须去查看这个逻辑，以找出，你知道，我们实际会得到什么内容。

我们看一下逻辑，我们看到它要求有一个前向范围。然后当它是const限定时，这个范围也需要是一个前向范围。然后再次，当它是const限定时，它还需要是一个公共范围。只有这样我们才能得到一个公共范围。否则我们得到一个非公共范围。这非常冗长，对某人来说很难理解。我自己也读了几遍才理解它在说什么。所以我认为它并没有真正清晰地传达信息，让人们理解这里发生了什么。他们必须费很大劲才能到这里。

所以现在，现在我们应该思考，嗯，范围的用户真正需要知道什么？他们应该知道的东西包括类型要求。这以概念的形式出现，包含所有三种要求。我们有前置和后置条件。我们想知道如何构造范围。当我们解引用迭代器时会发生什么？它会是引用类型还是我们会得到某种对象？范围的类别是什么？它会是一个输入范围吗？它会是一个随机访问范围吗？范围是否是有大小的？我们实际上会得到一个公共范围吗？我们能const限定它并遍历它吗？最后，它是否是所谓的可借用范围，这是只在C++20设计周期后期才引入的东西。

那么让我们看看其他库是如何呈现这些的。我们从Range V3的`stride_view`开始。这个`stride_view`是一种跳过元素的方式，跳过一些恒定数量的元素。所以如果我们看这个特定的文档片段，我们可以看到它非常简略，这里没有特别多的内容。所以它，它没有真正解决用户的需求，即告诉人们如何使用它，甚至它代表什么。所以它不太适合上下文。它没有清楚地说明是什么或如何使用它。所以它在清晰度方面确实有所欠缺，而且它不太容易消化，因为没有太多东西可消化。这进而导致它不完整。找到这个特定的东西也花了我一些时间。所以它不太容易访问，但它是及时更新的。这主要是因为它文档如此简略的结果。

这是我们对良好文档高层需求的分析。那么对于用户需要知道的东西呢？嗯，它确实有一些类型要求。它在底部说我们需要在`difference_type`上有这个类似整数的东西，但它没有告诉我们关于范围的任何信息。它也没有告诉我们关于`stride`的前置条件，我们稍后会讲到。没有关于如何构造或使用的信息。我们不知道当我们在迭代器上解引用时会得到什么。我们不知道它会是输入范围还是带大小的随机访问范围。我们不知道它最终会是公共范围，或者我们能否遍历这个的常量版本。我们也不知道它是否可借用。所以这是对Range V3文档的一个观察。

然后我们有像Boost Range 2.0的`strided`。我们来看看它与Range V3的对比。所以立刻就有大量的文档，它不仅谈论`strided`的用法，还通过例子告诉你一些事情。所以它适合上下文。它非常清晰地说明了正在发生的事情。它以项目符号列表的形式列出所有内容，并在底部给你一个例子。它是易于消化的，因为它被分成几个部分，有表格和项目符号。不幸的是，它不完整。它确实涵盖了诸如前置条件是你必须有一个非负整数这样的事情，但它没有告诉我们允许传递什么样的范围。它是部分可访问的，因为它100%是文本，这意味着屏幕阅读器或在你的网页浏览器中放大到200%或300%会非常容易做到。不幸的是，尽管这个特定的Boost库有一个很棒的目录，但找到`strided`文档仍然花了我不少点击。所以我在这里只给它部分分数。但它似乎是最新的，这很棒。

然后让我们看看用户需要知道什么。我们已经说过类型要求不存在。这是我之前说它不完整的原因之一。它确实涵盖了前置条件，这很棒。它向我们展示了不仅如何使用构造函数构造，还如何使用管道语法，并告诉我们这一点。不幸的是，它没有告诉我们引用类型，但它确实提到范围类别是单次遍历范围，这本质上是另一种说法，即它是一个输入范围。它没有提到它是否有大小，不幸的是。然后关于是公共、可常量迭代和可借用的最后三点，我打算放它一马，因为Boost Range 2.0，我想是2010年代的东西，而这最后三点至少是2014年至今时代的东西。但这并不意味着我不会把这些事情提出来。通过说明“嘿，我们现在是2021年了，也许我们至少应该说明一下”，即使库不涵盖这类东西，我们仍然可以记录这些特性在这个特定的库中不存在，这可以在很大程度上完成文档。

那么，Sy，这些信息实际上应该如何呈现，以我们的观点？是的。我花了很多时间思考，嗯，我们实际上应该如何记录这些东西？你知道，我们之前的一个关键点是概念可以用作文档工具。所以让我们想想如何应用概念以及我们一直在谈论的所有那些维度来改进这个文档。

我们将以`cycle_view`为例。这是Range V3的，只是作为比较。我们要做的是从一个高层次的描述开始。我们会说`cycle_view`将一个视图变成一个无限循环的视图。然后我们会有一个例子。我认为这是一个很好的方式，可以拥有清晰度、适合其目的、让它易于消化。大多数用户喜欢例子，对吧？对于像`views::cycle`这样的东西，我们想快速上手并让它运行起来，这非常完美。所以我们从一个高层描述和一个例子开始。

然后我们开始分解我们的概念。所以我们有我们的类型要求。我们要求`V`是前向范围并且是视图。我们的引用类型和`V`相同。我们的类别稍微复杂一点。所以我们把它分解成项目符号点：如果`V`是随机访问和带大小的，以及其他一些细节。最后我们说它从来不是带大小的或公共的或可借用的，但如果`V`是可常量迭代的，那么它也是可常量迭代的。这些都是我们可以通过查看签名推断出来的。但这只是使用概念的共享词汇为我们清晰地列出一切。如果我们理解什么是前向范围，我们就理解这个文档。编译器也理解。

然后我们告诉你如何构造它。我们说你可以不带任何参数地管道连接它。我们给你一个例子，并展示如何用函数调用语法构造它。所以我们说要通过多个维度来衡量你的文档质量。那么让我们想想这个。对于上下文，我认为我们思考了受众的需求。我认为它清晰且易于消化。我们布局了清晰的部分。我们使用了标题、项目符号点。我们思考了如何布局这些信息。你会思考如何在网页上布局，这可能略有不同，但仅就幻灯片而言，你可以想象这会如何转化。

完整。同样，我们思考的是用户实际使用这个库需要什么。所以我认为就这个标准而言，它是完整的。

可访问性。同样，这在某种程度上取决于你如何将其转化为网页。

及时更新。所以这是手写和手动维护的。如果你改变了某个类型的签名，那么你可能会以不明显的方式影响这些内容。所以你需要小心那里。

让我们看一个稍微复杂一点的例子。假设是`chunk_by_key_view`。这是一个可能不那么明显的东西，比如`cycle`。但`chunk_by`是一个将范围分块为子范围的视图，其中连续的元素共享由投影函数给出的相同键。所以这有点像隐喻。我们需要知道什么是投影函数之类的东西。但我们有一个例子。所以我们有像Marshmallow这样的猫。你可以说嗨。这是Marshmallow。他很柔软，很爱睡觉。所以我们有猫，我们的猫有名字和年龄。然后我们展示如何按年龄对这些猫进行分块。所以我们的第一组有前两只，年龄12岁。然后我们有另一只9岁的猫，然后又有两只12岁的猫。你看到这些被分成了三组。连续元素具有由投影函数给出的相同键。

然后我们分解我们的概念。所以我们说它需要前向范围，需要视图。然后我们有这个稍微复杂一点的`indirect_unary_predicate`。同样，这是你必须知道的东西，或者是我们决定用散文额外描述的东西。然后我们有我们的引用类型。我们的引用类型也开始变得有点复杂。我们得到了一个`std::pair`，其中包含调用该函数的间接结果和一个我们迭代器的子范围。所以也许我们认为这开始变得复杂了。所以我们给一个例子。我们说如果`v`是`vector<int>`，`f`是从`int`到`bool`的函数，那么你会得到一个`pair<bool, subrange<vector::iterator>>`。你看到这有点处于我们认为纯粹用概念记录还是切换到其他方式的分界线上。

Leslie有一个问题。一些文档将Sphinx的东西隐藏在签名中，并使用纯文本来描述要求。所以也许我们可以在这里做类似的事情，或者我们可以将其中一些提取到一个细节概念之类的东西中。只要我们思考我们的受众和文档的所有那些品质，就有很多事情可以做。

然后我们继续讨论其他概念，这些更容易处理一些。类别始终是前向，从不是带大小的、公共的、可常量迭代的、可借用的。我们展示如何构造它。然后我们展示如何使用管道语法。我认为这就是我们需要的所有信息。

所以再次，我认为什么是好的文档，这种形式与另一个非常相似，适合上下文。我们考虑了很多我们的受众，试图思考如果这变得更复杂，我们可能想以稍微不同的方式展示东西或提取出一些内容。同样，它将是手动维护的。所以我们需要考虑到这一点。但我认为这是记录这类范围适配器的一个好方法，通过采用概念的共享词汇，为用户和编译器使用它，并始终思考用户，始终思考我们的受众，始终考虑这些文档的维度。

那么，既然我们已经稍微看了一下范围，让我们思考一下，我们应该如何改变记录C++代码的方式？Chris，你怎么看？

作为用户，我们应该向实现者要求什么？嗯，我们应该要求我们的文档适合上下文。我们应该要求它清晰且易于消化。它需要完整、可访问和及时更新。这确实是我们整个演讲过程中一直在谈论的所有内容。

有人问的一个问题是：我们如何让像cppreference这样的网站改变文档内容？嗯，有几种方法可以做到。这肯定归结于让他们去做并请求他们去做。在像cppreference这样的网站上有讨论页，你可以在上面发表意见说，嘿，我希望它被改变。你可以去CPP的Discord频道Hatchery，然后在那里讨论。有多种方法可以做到。它是一个维基，所以如果你感觉足够强烈，你可以自己做出更改。但讨论区是获得对这类事情支持的好方法。

但我们真正想强调的是，如果你不要求这类东西，它就不会变得更好。几年前在标准C++会议上，一位编译器开发者说，我们不把编译器错误信息做得更好的唯一原因是因为用户不抱怨它们。这相当令人震惊。编译器错误信息是真正应该好且有帮助的东西。所以你需要开始要求事情变得更好。这样世界才能进步。

以Range V3基于头文件的东西为例，我们谈过你需要注意这个“READ THIS”位，然后知道这意味着请去这个头文件。然后你就能得到那个很棒的散文文档。如果不是这样，而是编译器有一种方式让库开发者实际把这个消息放进你得到的诊断信息中呢？这样用户就能在散文中看到哪里出错了。现在，一旦你说服了一位编译器工程师去实现这个，并让它进入你的编译器，然后你需要回去找你的库开发者说，嘿，编译器使用了这个。请开始使用它。这样我们才能真正为我们维护的库获得更好的文档和更好的诊断信息。

我们真正想强调的是，如果你不要求改变，它就不会变得更好。

那么让我们也思考一下，作为实现者，我们如何帮助我们的用户？我认为这又回到了我们在整个演讲中提出的所有关键点。那些就是：

1. **了解你的受众**。思考你为谁编写文档，并针对那些人量身定制。
2. **通过多个维度衡量你的文档质量**。我们给了你一堆可以考虑的维度。也许你有自己的维度。也许有些关于你受众的事情我们知道你不知道，你可以用它们作为指导你文档质量的标准。
3. **使用可用的工具来最大化你的文档质量**。我们不会告诉你使用什么工具。我们不希望你教条化。我们希望你在了解可用的工具基础上做决定。
4. **概念可以用作文档工具**。我认为我们已经向你展示了你可以做到这一点的好方法，但它们也可能被误用。不要仅仅因为编译器也理解概念就把它们当作大棒来用。思考你的受众。

我认为如果你遵循所有这些关键点，那么你的文档将会好得多。

非常感谢大家。好的，我们还有大约一分钟时间提问。Chris，我想你大概已经回答了关于cppreference的那个问题。

**如何在不过度文档化的情况下恰当地记录一个API？**

有趣。这是一个非常好的问题。我认为这在很大程度上归结于思考你的受众。当然，对于像C++这样的东西，很多时候你的受众将是双重受众，可能是库的新手和高级用户。所以思考如何以一种对这两种人都有用的方式呈现这些信息。比如把例子放在顶部，或者可能把高级信息隐藏在类似勾选框之类的东西后面。就是思考你的受众，思考他们需要什么，以及你受众中不同群体需要什么。

Chris，你对此有什么想法吗？基本上，你刚才说的总结了我所想的全部。酷。

我们时间快到了。如果有人有最后一个问题，也许可以问一下。Marshmallow目前正试图挖洞钻出我的房间，这有点令人印象深刻。但我们会待在Gather Town空间里，如果你有任何进一步的问题，或者你可以在Twitter上联系我们俩。我是@TartanLlama。Chris是@cjdb_ns。Marshmallow在Twitter上也很活跃。或者你可以通过Discord联系我们。但非常感谢大家的参与，希望你们享受会议的其余部分。再见。谢谢。
