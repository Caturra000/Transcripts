# 零成本抽象：消息分发

标题：Zero-Cost Abstractions in C++ - High Performance Message Dispatch

日期：2024/09/09

作者：Luke Valenty

链接：[https://www.youtube.com/watch?v=DLgM570cujU](https://www.youtube.com/watch?v=DLgM570cujU)

注意：此为 **AI 翻译生成** 的中文转录稿，详细说明请参阅仓库中的 [README](/README.md) 文件。

备注：介绍 Intel 的 cib 库，要看视频中的代码才知道啥意思。

-------

今天我想谈几件事。这是一个关于零成本抽象的案例研究，主要围绕这个高性能消息分发（message dispatch）算法及其接口展开。所以我希望能讲好这个故事。这会很有趣，你们会学到一些新东西，并以稍微不同的方式思考问题。

我是 Luke Valenty，英特尔的首席工程师。我有幸能与 Michael Case 和 Ben Dean 一起开发电源管理固件。自从几年前转到 C++ 以来，我也和 Michael 和 Ben 一起在工作中倡导使用 C++。我是一个父亲，我有两个孩子。我是《星际迷航》的粉丝。我不是那种超级狂热粉（Trekkie），但我喜欢这些剧集。

幻灯片上会有很多代码。在大多数情况下，我都省略了 `constexpr`、`no discard`、`no accept`。请假设我会把它们放在你们认为该放的地方，这样我们大家都开心。演示文稿的一部分改编自 Ben Dean 的“Message handling with Boolean implication”。我会谈论消息处理部分和大量的布尔数学，但不会涉及蕴含（implication）部分。那部分你们得去看 Ben 的演讲。所以当你看到我看向 Ben 时，那就是我们在讨论他的幻灯片的时候。

在深入这个案例研究的细节之前，有必要了解我所处的环境，以及这到底意味着什么？开发电源管理固件意味着什么？有哪些特性，这到底是什么？

电源管理固件，它协调我们系统中（我们的英特尔系统中）组件的电源开启和关闭事件。我就说到这里，因为这是一项巨大的工作。当你打开电脑时，你期望它能启动。但除了进入和退出活动状态、睡眠状态或完全断电状态之外，我们还管理活动功率与性能的权衡。我们报告能源使用情况，作为系统的核心中心部分，我们参与了许多流程。我们了解很多关于电力使用的信息，让我们来做这件事是合理的。最后，我们要防止过流和过温情况，以及其他我们要负责的随机特性。

我们的固件必须极其稳健（robust）。没有它，什么都启动不了。当我们拿回第一块硅片时，这就像是第一件需要运行的事情。它必须是高性能的。我们响应事件的速度越快，我们的电源管理就越好，实际上电池使用量就越低。芯片上的硬件本身需要节能，这限制了我们。非常非常重要的一点是，我们需要具有高度的延展性（malleable），我们需要每年适应新的产品需求和新产品。

这是一张我们前段时间发布的关于 Meteor Lake 的框图。Meteor Lake 的很酷之处在于我们在封装中有几个不同的裸片（die）。你知道，也就是你认为的芯片。我们将它们封装在一起。那个 PMC，就是我们工作的对象，也是我们编写固件和运行固件的地方。现在有两个 PMC。这对我们来说是新事物。这很不同。在我们之前的项目中，我们有一个 PMC，我们与一定数量的组件和电源流程进行对话。但现在我们有两个，这有点让我们大吃一惊。我们有不同的接口，我们必须管理这些接口的电源。我们的芯片上有了全新的邻居，那是从 CPU 上移下来的，我们在那里有一个新组件，实际上我们必须与之紧密接口。我们有一些新的 IP。我们有额外的电源流程。

所以我们必须乐于接受变化。我们必须解耦我们的组件，这样我们就可以挑选和选择。好的，我们有这个组件的驱动程序。我们这里有这个特性。我们需要从一个项目到另一个项目进行挑选和选择。我们必须具有延展性，这样我们要么可以实际完成我们的工作，要么可以执行我们需要执行的项目数量。我们可以适应架构提出的任何要求。我们希望支持他们。

我们必须高效节能。这意味着我们没有大内存，因为我们一直开着机，我们不想耗尽你的电池。这也意味着我们需要一个高效节能的处理器。所以我们有一个非常非常小的核心，如果你不用显微镜可能都看不到它。我们的时钟频率很慢。所以我们必须榨干每一的一点性能来完成我们的工作。当然，我们必须管理好自己的电源状态并做好这件事。

与此同时，我们必须快。我们需要低延迟。我们必须迅速响应。我们需要高吞吐量。这里加了引号，因为你知道，它不是一个非常强大的 CPU。但我们希望利用零成本和负成本抽象，这是 C++ 真正擅长的东西。所以数学和科学是我们的朋友。我们可以研究我们的实现，我们可以弄清楚我们需要使用什么样的算法？有哪些我们可以利用的基础数学概念等等。

> **听众提问：** 你能给我一个数字吗？你们需要满足的最低延迟要求是多少？

这是一个有趣的问题。我不能说。但它必须很快。是的，是的，是的。微秒就像是一个永恒（eon）。

> **听众：** 你能用周期数来说吗？

不。它必须很快。一微秒是一段很长的时间。好的。而且我们不是在运行 2GHz、3GHz 的乱序处理器。所以，你知道，这有一个权衡三角，我们放弃了内存和处理器速度。但我们有 `constexpr`，我们可以容忍编译时间。而且还是那句话，你知道，我们的两个朋友，科学和数学，它们可以帮助我们做很酷的事情。

我们必须稳健。据我了解，硅芯片是用沙子和大量的钱制成的。当你把这两样东西放在一起，你就得到了产品。如果固件工作不正常，人们会非常不高兴。那非常非常昂贵。所以我们可以越早发现 bug，越早确保我们的固件是正确的，成本就越低，我们大家就越高兴。这包括生存能力（survivability）之类的东西，对吧？我们可以更改固件。

那么这对我们的固件设计有什么影响呢？显然是用于组合和扩展的零成本和负成本机制。所以我们希望能够组合东西。我们不想写那些到处依赖非常具体细节的垃圾代码。那样我们会得到一团乱麻。我们不想做那种事情，比如，哦，我们要么有这个 `if` 语句，我们只是调用所有这些其他模块，对吧？那让我们非常难过。我们经历过。我们要知道那是什么样的。我们需要稳定的、可扩展的和声明式的接口。我实际上应该把**声明式**强调得比什么都重要。我们希望启用通过构造保证正确性（correct by construction）的技术。我们在编译时能证明的事情越多，运行时失败的事情就越少。

所以基于这些限制和过去的痛苦，我们开发了这种模式。它最初是一种模式，后来变成了一个库，即**编译时初始化和构建库（CIB）**。基本上，它让我们能做一些很棒的事情，比如注册回调。我们可以有一系列回调。我们可以注册一个依赖于另一个回调的回调。我们可以有非常复杂的依赖图，它在编译时就能解决。事情会被内联和优化。我们不会通过虚指针，也不会通过函数指针之类的东西。我们需要有一种好的方式来实现这一点。

所以我们可以按组件组织代码。我们可以有一个顶层项目组件。我们有不同的组件，可能是有驱动程序的设备。我们需要与它们接口。我们需要为了特性、为了电源管理之类的东西与它们对话。Foo, Bar 和 Baz。这就是我们要做的。细节并不是超级重要，但在我们的组件内部，还有另一个划分：**服务（Services）**和**特性（Features）**。

在 CIB 中，服务是可以扩展的东西。对吧？例如，我们可以接收一条消息。我们将该消息发送到哪里？有一大堆其他特性想要在特定条件下注册回调。对吧？所以特性可以扩展服务。这就是力量。这是 CIB 赋予我们的能力。它让我们非常高效地做到这一点。

我们拿着我们的顶层组件，它被传入 CIB Nexus。Nexus 是事物的汇聚点。如果你看了 Tony 的演讲，不要把它想成是复结（complexing）。因为在这种情况下，我们不是在把事情变得复杂。实际上，我们将事物汇聚在一起，以便我们可以在编译时修改服务。这样我们就可以在编译时扩展服务。所以我们的特性在源代码中知道服务，而不是反过来。由此我们得到实例化。我们得到了对所有我们可能需要访问和调用的服务的实现，现在它们已经被扩展了。

**特性**。它们由客户控制。大多数时候，我不会提出我们需要的一个特性。大多数时候，我们有架构师。他们就像是，嘿，我们有这个新东西。你需要为它做这个奇怪的事情才能让它工作。或者我们有这个想要使用的新标准。或者我们有这种新的解聚（disaggregation）。这意味着你有这个 IOE 裸片，你将在 SOC 裸片中，它们需要协同工作。持续的变化。这是我们要么唯一可以预期的事情就是持续的变化。这就是我们获得报酬的原因。我们为客户提供价值。这就是业务逻辑。对吧？

然后是有趣的东西，我喜欢的，它是**服务**。我们控制这个。我们定义这个。我们要么为自己创建稳定的接口。服务为我们，为开发人员提供价值，以便我们可以实现我们的特性。我们的源代码依赖关系是这样的：特性知道服务。这很重要。这就是依赖倒置（Dependency Inversion）。这来自 SOLID 原则的一些好东西。

那么一个组件实际上是什么样子的呢？嗯，它是一个结构体或类。但要与 CIB 一起工作，它有这个编译时声明。这个 `constexpr` 声明。它是 `CIB_config`。所以这个组件暴露了一个 PCIe 处理程序。某种 PCI Express 消息处理程序。对吧？所以它向 CIB 宣传这是我拥有的服务。其他人可以扩展它。我也可以扩展它。所以它也有一些消息回调，它也将用这些回调扩展该服务。

服务本身……嗯，它就像一个服务名称。所以它声明了一个符合某种服务类型的可扩展接口。这是一个消息服务。对吧？消息以某种方式发送给它。它将把它分发给请求它们的适当回调。所以它连接……服务名称连接了一个通用接口和一个特定实现。在这个消息服务下。所以我们有我们的名称、类型和它的配置。我们在这个上稍微跳过一点。那就是那个小星星的意思，因为我们会看到这个几次。

这就是我们的消息回调特性的样子。对吧？这是我们可以拥有的特性中最小的部分。它有一个名字。它说我们想要什么样的消息。它有一个谓词（predicate），说，这些是我期望这条消息具有的运行时值，我才能处理。如果没有这些，那我就不关心它。它有一个 lambda 或可调用对象来对其进行一些处理。这就是我们如何挂钩到消息服务中。

我们有我们的顶级组件。组件可以由其他组件组成。这有点像它们就是为了组合而生的。Nexus，再次强调，是我们把所有东西汇聚在一起的地方。所以你只需实例化一个 Nexus。你传递给它你的顶层组件。仅仅这一步，这行代码，就完成了所有的编译时初始化和构建过程。我实际上在这段代码中有一个 bug，因为这一部分 100% 会是未初始化的。所以你实际上需要在 Nexus 上调用 `init`，这样你才能获得进入所有服务的类型擦除接口。否则，你只能从 Nexus 访问服务，当你试图从扩展不同服务的特性中调用服务时，这会导致不可能的循环依赖。所以不管怎样，我们通过 CIB 服务提供了这种类型擦除。

我不是某一天突然想出这个并让它工作的。我有很多非常糟糕的实现。我并没有完全意识到我在做什么。但我知道我需要这样做，因为那个带有依赖项的回调系统对于我们进行组合至关重要。如果我们要在运行时做这件事，它在物理上是不合适的，无论是在时间上还是在内存上。

所以我有一个特定的实现来做这件事，它有点用。然后它被稍微泛化以支持消息处理。然后它被完全泛化，但所有的配置都是命令式的，这很糟糕。当特性被添加到服务时，它们被类型擦除了。我们丢失了很多信息，也失去了很多机会。第四次迭代是现在 GitHub 上的开源 CIB 库。几年前我在 Embo++ 做过一次完整的演讲。那是虚拟的，但我确信我在讲的时候人们的眼睛都在呆滞，因为我讲了很多关于它是如何工作的细节，并展示了代码。但我玩得很开心。我想其他几个人也是。

> **听众：** 很棒的演讲。很棒的演讲。

哦，谢谢。如果你感兴趣，可以去看看。那个演讲链接在 GitHub 上。

所以，消息分发。这是我们的案例研究。它是什么？很简单。我们有一条消息。我们解码那条消息，然后我们将它发送到某个地方。我们有固件中的其他组件需要处理它。

让我们看看 PCI Express。PCI Express 是一个很棒的接口。它已经存在了一段时间了。它基于 PCI。现代计算机中的许多总线，内部总线，都需要通过 PCI Express 进行对话。所以有共性是很有道理的。

但它只是一个结构体。它是一些带有位压缩字段的 D Word。这些字段有含义和位置。我们需要访问它并处理它。所以我们从某个网络、从某个接口得到像 PCI 数据包这样的东西。它进入我们的消息处理程序，然后被分发到一些回调。这种情况经常发生，我们要高效地做这件事。我们要快速地做这件事。

它不仅仅用于硬件。你可以将其用于硬件总线协议之外的某种事件总线或消息队列架构。但是，是的。

我总是喜欢谈论事情应该是什么样的。第一件事总是它应该是正确的。它应该是稳健的。它应该工作。它应该做它应该做的事情。

但是你知道，还有其他属性。我们想享受使用它的过程。我们要么希望做正确的事情很容易，做错误的事情很难。

让我们先反过来看。这与我们过去的一些代码并没有太大的不同。这里的一切都是错的。这根本不是 C++。这在各方面都很糟糕。我们要谈谈它是如何糟糕的。不类型安全，不可维护，容易出错。为什么它不可维护？因为它不可维护是因为你有一个服务正在获取这些消息，而该服务知道你曾经拥有过的每一个特性，甚至可能是曾经拥有过的。而且你可能正在做 `if define` 或 `if` 语句来禁用。所以这真的很糟糕且容易出错。我们 100% 会搞砸这个。

我们要怎么让它变得更好？嗯，有一大堆显而易见的事情。类型安全，编译时编程，你知道，识别并提升基本概念。我们要做的，我们要做的，结果与如何在这里做完全混淆了。这应该让我们所有人都感到不快。所以我们要使用声明式风格。我们要解耦事物，我们要让它快。我想根据情况改变我的分发算法，我不知道，也许有一天我只是对某件事感到非常兴奋，我开始专注于它，我想让它变得更好，我不想破坏一切。我想能够独立地做这件事，我不想去遍历代码库并更改我们使用它的每一个位置。

> **听众：** 这不是伏笔。别担心。别担心。别担心。

所以，你知道，我们可以整理这个。我在这里所做的一切就是我注意到这两个字段结合在一起意味着数据包类型。所以我稍微简化了一点。这并不多。但是你知道吗？有一个类型来表示枚举会很好。那会很好。所以我们这么做。我们有了那个。

然后，你知道，原始指针就像，我们做嵌入式固件。我们在几乎任何情况下都不需要原始指针。我们使用它们的案例应该非常少。我可以准确地说。我们可以使用 `case` 语句。但这件东西的另一件可怕的事情是，比如我们只是得到一个 `span`，对吧？这里没有我们要处理的字段的类型安全。你知道，我们必须有这些函数 `get packet type`，但也只是接受一个 `span`。比如，这是正确的吗？这是用于 PCIe 的 `get packet type` 还是用于 USB 或其他东西的 `get packet type`？我不知道。我希望它是对的。它可能应该是，因为它正在获取那个数据包类型。我也不知那是不是对的。

不管怎样，我们想要一个适当的数据结构来表示我们的消息，对吧？我们想要一种声明式地描述一次的东西。这些是我们拥有的字段，对吧？这些是字段的名称。我们有这个编译时字符串，我们在固件中到处使用编译时字符串。但在我们的二进制文件中没有一个字节的字符串数据。我们在 CIB 中有一个日志系统，它在某种程度上为我们处理了这个问题。那是我去年做的一个演讲。

所以我们有所有这些字段，字段可以有类型。这只是一个无符号 8 位整数的别名。以及我们的消息定义。顺便说一句，这只是一个定义，字段是定义。消息是一个定义。它们是不包含数据的空类型。它们只是描述。消息只是字段的集合。

所以现在我们可以……这不太对。这应该是一个……不，这很好。让我们使用这个版本的消息。这是头部（header）。所以头部将包含一个类型，对吧？它包含相同的类型字段，但我不需要知道其他细节。我不知道这是什么类型的消息。不同的消息类型可能包含不同的字段，对吧？这是我分发所需的最低限度。所以现在我只获取类型。这也是一个编译时字符串。所以做这件事没有运行时成本。可能有编译时成本。我们去处理这个。

这解决了很多问题。它是更类型安全的，但注意我们仍然在传递这个消息。这是 `const view`。它不拥有存储，但它允许我们通过消息接口查看底层存储。我们仍然在传递相同的消息数据，它没有描述其他字段。它没有描述，哦，这是一个内存读取。我应该有一个地址，我应该有其他几个属性和一个标签。我们仍然没有那个。所以我们不类型安全。是的，因为我们的处理函数只是获取这个头部。我们仍然需要强制转换到更具体的类型。所以再次强调，并不真正的可扩展和可维护。

现在是处理内存读取的下一层级，例如。也许我们的固件实现了一个硬件寄存器接口。所以我们的主机 CPU 操作系统正在读取电源管理单元的一些东西。也许它去硬件。也许它去固件。也许我们有不同的固件组件处理地址空间中的不同页面。所以同样，不同的特性有它们自己不同的寄存器集。现在我们要把它们放在一起。这绝对是复合（complexing）。我们把所有这些放在一个应该是通用的地方，现在它一点也不通用了。

好的。所以我们可以有一大堆服务。我们有特性。如果我们像上一张幻灯片那样实现事情，现在我们的服务依赖于我们所有的特性，这太糟糕了。因为我们唯一的确定性是我们的特性会一直变化。没有一致性。它们永远不会相同。总是有新东西需要进去改变它。所以这不是我们想要依赖事物的方式。我们不想让我们的核心功能受到影响。

相反，我们要使用 CIB，我们希望我们的特性依赖于服务。对吧？所以我们可以删除一个特性，这没问题。我们可以添加一个新特性，这也没问题。我不认为这有什么革命性的。

但是要修复这个问题需要更大的改变。我们不能只是在幻灯片上零敲碎打地重构它。我们需要转移到 CIB 中的消息服务和消息回调。我们可以用类似的方式稍微研究一下这个问题。不使用我们拥有的最终 API，而是让我们推理一下为什么我们需要那个 API。让我们研究一下，如果我们做得不对，会有什么问题？

所以这里我们有消息回调。它接受一种类型的消息，它只是一个 Lambda 表达式。对吧？所以我们需要条件是在 Lambda 内部的。这是功能性的。这工作得很好。对吧？从功能角度来看，这没有任何问题。

但是，你知道，我们喜欢调试东西。当我们收到一条消息时，我想知道，这条消息是否匹配我们的一个回调？不仅我想知道，我希望我们的验证工程师知道，这样他们就不必问我发生了什么。他们可以查看日志并找出答案。这非常有帮助。

最后，它帮助我们将消息定义移动到模板参数中。因为我们可以，有一些黑客手段和技巧可以从 Lambda 推断出消息类型是什么，但这并不好。它不稳健。它不能保证总是有效。所以我们将消息定义类型放入，我们将其暴露给库。我们在接口上暴露它。稍后会更清楚为什么这有用。

最后，我们实际上希望谓词（predicate）成为我们库接口的一等公民。这对我们来说非常重要，因为，好吧，如果我们这样做，有很多有趣的事情可以帮助我们。

最后，为了让我们获得类型安全，真正的类型安全消息处理。我们要我们的消息定义描述该类型的有效消息的运行时要求。所以消息中存在的字段可以取决于某些类型字段或某些操作码字段或某些命令字段。也许有一个子命令或子操作码。也许有标志改变它的格式化方式。32 位地址与 64 位地址字段。如果我们的消息定义本身也包含，哦，对于这个定义是有效的，对于一条消息是这种类型，操作码必须是 `memread32`。那么它就是有效的。

现在，我们的库可以确保如果我们要匹配这个，我们要确保这是正确的。我们要确保该消息的页面字段为零。我们要确保满足此消息定义的所有要求。所以它将是一个 `memread32`。

> **听众提问：** 好的，所以我想我在你讲到……之前可能已经有了答案。我就想，为什么你不能只有你要求字段和你谓词字段？你可以验证所有这些。这更多是关于加倍下注，以便你可以在编译时静态地做到这一点。

这将在编译时进行评估。对不起，不是在编译时。这是在编译时已知的。我们在编译时向库宣传这一点。我想把它和消息定义放在一起，因为创建这个消息定义的人，他们正在看规范。他们知道它应该是什么。他们正在检查他们的工作。它经过了审查。它是好的。它进入我们的代码库。然后我要添加一个回调。我想，哦是的，我知道 `memread32` 是什么。我会说，嗯，命令是 `memread32`。这就是我放进去的。除了也许我忘了，哦，这另一个位必须设置为 1。对吧？我现在不能搞砸那个了。因为这个定义包含要求。所以任何时候我想要这样的消息，我保证只会得到那个消息。然后它与这些要求结合在一起。这就是原因。因为我不信任我自己。对吧？我们会犯错。

我们有我们的名字，我们的消息类型，我们的谓词，然后我们有我们的动作。

> **听众：** 那个谓词是一个 DSL（领域特定语言），以防你放了一个……。

是的。是的。所以那是一个领域特定语言。这是一种非常晦涩的语言，叫做布尔代数。布尔表达式。

> **听众：** 有点像，这些框架做它们的事情吗？或者看起来像表达式的东西？

哦，是的。像这样。我的意思是，一些单元测试框架会查看表达式或重载操作符。是的。有点像那样。但基本上，我们知道 AST（抽象语法树）。所以我稍后会详细介绍那个。

所以我们有我们的字段。再次强调，我们在这里看到 Ben 的名字。我现在要更频繁地看看 Ben 了。这些取自他的幻灯片。我们已经讨论过字段了。但还有几件事我们要确保在这里设置。所以其中一件好事是我们实际上可以有多个字段定位器。所以我们可以将字段拆分到多个位置。

这是我们同样的 PCI Express 数据包示例。我们的内存读取有相同的字段。我们有用于组成消息的标签。我们可以在谓词中使用它。或者我们可以在谓词中使用名称。所以这实际上是，如果如果不使用名称，会更好一点。因为在不同的数据包中，你可能有不同的字段位置。对吧？所以如果你使用这个名称，你可以为不同的数据包类型重用相同的谓词，这有点好。你可以为此使用相同的 `get` 方法。

这对于分发还没有完全实现。但对于像获取字段这样的事情，它已经完全实现了。然后我们的位置可以，我们在示例中没有，但我们可以有多个位置。所以一个字段可以拆分到多个，多个点。

然后字段本身，它们是空类型，但它们描述了如何从范围中提取和插入字段。对吧？那么我们的消息只是字段的组合。所以我们有一个拥有的实例。所以这包含它自己的数组，适合所有字段。然后我们也有 `const view` 和 `mutable view`（Ben，是这么叫吗？），基本上是为了拥有引用，我们不拥有数据，但我们也不想复制它。

我们这样做而不是仅使用像按引用传递，是因为我们有某种消息类型。当我们解码字段时，我们还不知道它是什么消息类型。一旦我们看到，哦，它满足此消息定义的要求，那么我们基本上可以说，好的，这里是具有这些新字段的此消息的 `const view`。我们知道它是类型安全的。

我们的匹配器（matchers）是我们现在要多谈的一点。所以匹配器，它基本上只是，你知道，它有一个可调用对象，你传入一条消息，它返回真或假。就是这样。所以它是消息上的一个谓词。我们在所有示例中使用的简单匹配器是我们有一些编译时值等于该消息字段的值。对吧？我们可以使用关系操作符。是的，谢谢。然后我们可以，我们可以基本上有一个匹配器，并为不同的关系将其印出来。

但我们也可以将匹配器本身视为布尔值。当你这样做或者当 Ben 这样做时，你可以应用很多有趣的数学来进行变换并提取我们想要的信息以获得性能或其他我们想要的特性。但是是的，生成的管理器是我们的表达式模板。所以我们可以做 AND，它只是左侧和右侧的组合。然后我们评估双方并返回结果的 AND。OR 也是一样，NOT 也是一样。然后我们重载操作符，以便我们可以以一种好的方式组合这些。

所以我们可以定义字段和消息。我们可以描述如何匹配消息，我们可以将匹配器组合成任意布尔方程。

如果我们正在使用这个，而你没有使用完整的 CIB 模式，它看起来像这样。你可以，你知道，定义你的消息。你有你的回调，你可以创建一个处理程序。不要太仔细看这个，因为这不完全正确。但最终在处理程序上，有一个 `handle` 函数。那就是当你传入消息时，它将把它分发给适当的回调。

所以，不仅我们可以有，你知道，必须满足所有这些要求。它是任意布尔表达式。所以我们可以有 AND 和 OR。我们可以做关系操作符，等等。

再次强调，我们要花几次迭代才能弄清楚这一点。第一个版本没有类型安全。基本上是你传递一个数组，然后有这些可以在数组上使用的字段声明。然后它们知道如何提取和插入数据。那很尴尬，很痛苦。我还在为那个罪过付出代价。第二个版本有内置存储和类型安全，但存储管理方式有一些奇怪的怪癖。然后我们要当前的开源版本，由于 Michael 的大量批评反馈和 Ben 的大量工作，它一直在迭代改进。我也做了一些事情。我提交了一些 issue，然后他们做了工作。谢谢。

我们有这个声明式 API，这真的很好，但我们也，我们需要快速处理这些消息。这有点，你知道，除了组合我们的固件和在架构师添加和删除特性时添加和移除特性的能力之外。我们在响应速度上有硬性要求。

然后，你知道，那让我思考，我们要怎么做才能更快？我在想数据库，你知道，有这些索引来加速查询。也许我们可以为消息分发做类似的事情，对吧？除了我们需要把它倒过来。数据库使用索引来加速将一个查询与许多行匹配，但我们实际上想将一行、一条消息与许多不同的查询匹配，看看它连接到哪一个。

但是是的，我们可以，我们可以这样做，因为如果你考虑一行，一行有字段，你知道，数据结构，一条消息有特定值的字段。并且，你知道，简单地说，查询对特定值的字段有要求，对吧？所以那里有对称性，我们可以利用这一点。

这是一个非常简单的案例，你会在许多案例中看到这种手动实现。所以你有一条消息，或者你有一条指令，或者你有一个命令，它有一个操作码，对吧？所以你可以做的是，你知道，你创建一个 map 或创建一个数组，每个条目对应一个命令或一个操作码。然后为了弄清楚你要怎么处理这个，你获取操作码索引到 map 中，然后你调用你从那里得到的可调用对象或函数指针。然后那就去执行它。或者也许是因为没有找到任何东西而使用默认处理程序。这相对简单。这不，是的，人们一直在手动做这个。

当你需要基于多个字段加速查找时，它会变得稍微复杂一些。但事实证明，也没有糟糕多少。这个 map 在这里是，你知道，将操作码映射到零个或多个回调的列表，对吧？这些 map 在做同样的事情。操作码到零个或多个回调，某种类型的目标 ID 到零个或多个回调。

但还有一件额外的事情我们必须做。所以我们在 map 上进行查找，然后我们取回调的交集，对吧？如果在匹配操作码的列表和匹配目标的列表中都找到了回调，那么你知道该回调同时匹配这两个字段，对吧？所以它是一个内存读取，它是 32 位的，例如，类似那样。然后我们遍历那个回调列表并处理那些消息。

所以我们需要非常快的查找，我们需要非常快的交集操作。我们的数据结构需要允许我们这样做。

让我们看一个例子。比如说我们要进来一个内存读取，这是左边的回调列表。这些是回调的要求。所以它匹配内存读取。好的。所以我们有几个不同的回调匹配那个，加上一些将记录我们要么得到的每条消息的日志回调。它是针对页面 B 的。所以让我们看看谁匹配那个。嗯，这个家伙匹配。然后日志消息匹配。然后这里有一些源 ID。所以这匹配了一大堆东西，不是那个，而是那个。

那么我们将需要执行哪些回调？是的，是的，完全正确。所以针对页面 B 的内存读取，然后是日志消息，对吧？这还不错。我们可以用大脑推理出来。我们需要的数据结构是这些索引，对吧？所以这有点像是从不同的角度来看待它。所以我们有内存读取。所以我们将获得所有匹配它的回调。页面索引，页面 B。所以我们将获得那里的回调。源 ID 索引查找。它是一个默认值。所以是所有这些，对吧？不受信任。所以我们要么取这些，然后我们计算，好的，交集是什么？所有这些中常见的是什么？好的，酷。然后我们将只执行那些。

所以，你知道，我们应该能够非常快地做到这一点，并且它应该扩展得很好。对于交集计算，有几个不同的选项。

在演示文稿中，我把结果留到了最后。就像我在最后一刻才做基准测试一样。所以我们有有趣的结果。我们需要快速的交集计算和快速的索引查找。我们在编译时知道键（keys），对吧？我们在编译时知道所有键。所以我们可以根据这些数据优化我们的查找算法。

但我们的谓词结构需要稍微处理一下，因为我们需要弄清楚，好的，我们有这个任意布尔表达式。现在我们需要提取它期望在特定字段上的具体值是什么，对吧？我知道怎么通过它来做到这一点，对吧？所以我们有一些索引字段和一些非索引字段。比如我可以弄清楚。

所以这一个谓词匹配两个可能的备选方案。Memory32, page0, 和 traffic class1, TC1。或者 memory32 和 page1，对吧？我们有两行。所以我想要一个表，对吧？我想要将那个任意布尔表达式转换为某种表。我知道如何处理表。我知道如何使用它们。你知道，那是我大脑可以理解的东西。必须满足那三个条件。我的意思是，我不应该为此包括头部，因为那不是它的一部分。但是要么这一个需要被满足，要么这一个需要被满足。对于这每一行，那个、那个和那个都需要被满足。

所以我们可以，你知道，重新排列我们的表达式以匹配这个。这是等价的。它做同样的事情。只是看起来不同。我知道在程序上，我可以想，好的，我知道怎么把它变成一个表。我知道怎么处理那个。这就是**积之和形式（Sum of Products form）**。这很棒，因为有各种关于布尔表达式和简化它们的资料。而且，你知道，这是几百年的东西。这是数学。所以这很棒。我只需要知道它可以完成。对吧？它是可能的。它存在。

所以我们要现在做的是我们要拿着我们的回调。我们要用它们在编译时做大量的处理。所以让我们通过这些变换，看看我们如何能让这个谓词和这个回调在视觉上被变换，并思考，好的，我们的代码需要为此做什么？

首先，我们想把我们的消息要求与谓词结合起来。对吧？因为消息有一大堆要求。我们想包括那个。好的。那是 memory 32。很好。然后我们想转换为积之和形式。比如这在幻灯片上真的很容易。对吧？我就想，哦，这不会太难。然后我们可以实际做的，是非常简单的变换。每个积项（product term），我们只是把它做成它自己的回调。对吧？我们只是复制它。这很容易。比如我不需要做太多就能让它工作。我们给它相同的回调函数。所以我们的回调函数被提取出来了。它被这两个引用。好的。

但是如果我们只索引类型和页面，那么我们还有这个讨厌的小家伙，交通类别（traffic class）。我们需要以某种方式处理它。嗯，这也还不算太坏。理论上，我们只是把它拉出来，放入回调函数中。所以现在我们有了这种中间回调函数，它在检查未索引的字段。好的。酷。

所以现在我们要这两个回调。我们要去更新类型索引和页面索引。对吧？所以现在对于 memory 32，它可以是回调 0 或 1。页面。键 0 去回调 0。键 1 去回调 1。然后我们对我们在编译时拥有的所有回调做同样的事情。我们完全填满这些索引。

所以我对此非常兴奋。我认为这太棒了。去年我在 EMBO++ 做了一个演讲，亲自描述了这个算法。但我没有这部分。我向 Ben 和 Michael 提了一个非常无辜的小 issue。比如我们需要能够为此查找创建积之和表达式。比如我不能指望人们自动把它放入那种形式。对吧？

所以这是一堆改编自 Ben 的幻灯片。我哥哥会问我，嘿，Luke，你做得好吗（how are you doing - 你好吗/你做得如何）？我会说，我做得好（doing good）。但我哥哥会告诉我，你不是做得好（doing good - 做善事），Luke。你做得不错（doing well）。超人做善事（does good）。现在如果你再问我，我会说我做善事（doing good）。

所以 Augustus DeMorgan 和 George Boole，我们站在他们的肩膀上。我站在 Ben 的肩膀上，他站在他们的肩膀上。所以让我们回到这些布尔运算符。我们要用这些做一些有趣的事情。我们有这个，看起来像 AST，因为这是我们的 DSL。这是领域特定语言。幸运的是，这是一个非常知名和被充分理解的领域。对吧？这真的很重要。如果你的声明式风格基于，你的 DSL 基于某种有那么多历史的东西，这非常痛苦，它不太可能改变。

有些时候我们知道事情会是真的。比如我们有一个索引字段。好的，我想移除索引字段，把它们设为 true。对吧？我要假设我的索引会处理那个。如果我们这样做，嗯，我再次用大脑思考，我知道我可以简化那个。我知道那总是必须是 A。那太棒了。它是 A。对吧？但是，你知道，我们必须解释这个。我们必须在我们的库中编写这个代码，以便我们的库知道如何推理它。它知道如何简化它们。这是它基本上每次都能做的事情。

> **听众提问：** 这是一个很好的问题。库怎么知道如何简化像这样的事情？像这些不等式？

这是一个很好的问题，我今天不打算回答。所以我会指引你去看 Ben 的演讲，他在那里解释了这个。而且真的很酷。

但让我们从更容易的事情开始，我们可以做的事情。你知道，不担心不等式，只是具体的等式。所以我们可能想要某种总是为真和某种永远不为真的东西。对吧？这将帮助我们。这是一些，比如，我们将需要向我们的库描述的基本概念。True 和 False 被占用了。所以，你知道，它是 never（从不）和 always（总是）。

所以我们希望能够简化这个。编译器可以做到。对吧？编译器可以简化这些事情。但是编译器不知道我们的 AND 类和我们的 OR 类以及我们的 NOT 类。对吧？它不知道我们的匹配器。所以我们无法得到结果。

所以我们要创建一个函数来进行简化。当我看到这个时我真的很兴奋。那看起来很容易。但是，你知道，默认情况下，你不做任何事情。然后你需要特化它。你需要为 AND 特化它。如果 AND 的任何一边是 never，它就永远不可能是真的。对吧？它是零和零，零和一。它永远不为真。对吧？所以我们返回 never。如果一边是 always，那么我们可以把这一边简化为只是，我们可以把整个 AND 简化为另一边的内容。对吧？所以我们要对两边都这样做。如果它们都不是 always 或 never，那么，你知道，我们必须做完整的评估。我们不能简化它。

我们对 OR 做类似但不同的事情。如果任何一个是 always，整个事情简化为 always。如果其中一个是 never，那么它只是简化为另一个。对吧？

> **听众提问：** 在最后一种情况下，为什么你不直接返回原始匹配器？

因为你简化了子表达式？是的。谢谢。是的。所以在最顶层，我们必须简化子表达式。所以我们实际上，有效地，我们下到了节点，叶节点。我们要尽可能地简化它们。然后再回来。Ben 在讲蕴含（implication）用于此时对此进行了更详细的介绍。那是一个很棒的演讲，昨天发布的。我强烈建议大家去看看。

所以我这里会有一些空白。但现在我们的库知道如何做这件事了。这很重要，因为在它做完这个之后，它需要弄清楚如何转换为积之和或析取范式（disjunctive normal form）。所以就像我们看到的表，但有一些额外的规则。所以在任何 AND 项内部没有 OR 项。对吧？这是一个两层树。对吧？所以我们有一个顶部，我们有 OR。OR 指向 AND 项。除了 NOT 之外，下面没有其他东西。

所以前两个表达式。这些是积之和。对吧？最后两个不是。我们不能在顶部有一个 NOT。我们不能有一个完整积项的 NOT，那必须被转换。在底部我们不能做像 A AND (B OR C) AND D 这样的事情。对吧？那不在这种形式中。比如如果你视觉上思考它，你不能把那个直接转换成一个表。

所以我们需要两件东西。嗯，两件，三件。分配律。然后我们需要两个德摩根定律。分配律有点像，你知道，像你在做乘法 X 乘以 (B 加 C)。对吧？我们在布尔代数中做完全相同的分配。我不知道德摩根定律在算术中是否有等价物。但是德摩根定律允许我们在 AND 和 OR 之间转换事物。对吧？就像我们实现简化一样，我们想为积之和做这件事。所以我们要拿着我们简化的表达式，现在把它转换为积之和形式。

> **听众：** 你知道，它看起来是那样的。当有人为你做了所有的工作。

是的。所以如果我们有一个 NOT，我们不能在顶部有一个 NOT。对吧？所以如果 NOT 里面的匹配器是一个 AND，那么我们使用德摩根定律将其转换为两个否定项的 OR。对吧？但在我们这样做的时候，我们仍然想递归地执行积之和转换。如果底层的匹配器是一个 OR，那么同样，我们要用德摩根定律，我们要把它转换为一个 AND。

是的。好的。我本来想问 Ben 一个问题，但我正在读我自己的笔记。它回答了。

所以。所以我们需要这样做来把任何 OR 拿出来。对吧？我们想确保我们没有那个。所以我们必须再次应用那个。如果这些都不适用，如果里面不是 OR 或 AND，那么它将只是一个裸匹配器。对吧？它将只是节点的底部。所以我们只返回那个。我们返回 NOT。我们实际上不应用任何转换。

> **听众：** 那被简化了吗？是的。但那是，是的。

所以对于 OR，想象我们在顶层。OR 是和（sum），对吧？如果我们在顶层并在应用它，我们实际上不需要做任何其他事情，对吧？我们不需要做任何特别的事情。我们只想递归地应用它。

> **听众提问：** 我们会得到只是一个两层树吗？

最终将只是两层。在顶部，它将是 OR。在下一层，它将是 AND。然后它将是节点，单独的。所以只是概念上的，是的。

> **听众提问：** 所有的模板，ORT 和 ANT，它们只是二元模板，对吧？所以作为人类，我们可以认为是变参 OR，但它实际上是用二元实现的。

哦，是的。但是是的，但概念上，是的。是的，那是一张没放进去的幻灯片。变参很难做。二元更容易推理。Ben 有另一个演讲。

> **听众提问：** 所以从根回到叶子，你只是看到一堆 OR，然后是一堆 AND，然后是鼠标？

是的。是的。但在积之和中你永远不会在 AND 下面得到 OR，对吧？

好的。所以 Ben 有另一个演讲，他在那里更详细地介绍了这一部分，还有剪枝我们不使用的项，例如，因为我们已经在索引中处理了那个。

所以有两件超级重要的事情我们需要做，以便整个算法快。有超过两件，但我在想并且我当时在想的有两件。第一件是我们需，我们的索引必须快。它们必须非常非常快。我们需要它们快速进行查找。另一件是我们必须做一个快速的交集，对吧？然后其他的细节都是我没注意的那些。但我们会讲到的。

关于查找算法和像哈希图、二分搜索这些东西的好处是，有很多关于它的资料。有很多研究。有论文。有库。有维基百科文章。有 YouTube 视频。比如有这么多资源。以及其他像人们做的实现。

所以我们有几件事，比如，你知道，你可以做一个线性搜索。线性搜索对于小计数来说实际上非常棒。它很好，对于小尺寸没有什么能打败它。是的。二分搜索还可以。哈希查找非常棒。Std，你知道，库实现在 C++20 中不是 `constexpr`。所以不能用它们。还有像当它们是 `constexpr` 时，你在 `constexpr` 中构建它们，你不能直接把它们取出来，你知道，进入运行时，这很尴尬。所以我们真的不能用那些。让我们不考虑它们。

再次强调，线性搜索对于小数字来说很棒，但也许你确实想使用 `find if`。也许你不。也许你运行的架构，比如做条件判断真的很快。也许你想保证像某种，像最坏情况场景，你想保证那个。但是你知道，你不关心平均值。但是是的。所以二分搜索实际上相当慢，如果你不需要排序的话。所以我打算忽略那个。我们会，我们会，我们会比较它，但我打算某种程度上忽略那个。我们想要哈希查找，对吧？对于大量键，像一个通用的，你知道，一个通用的解决方案。我们要哈希查找。

所以这个叫做 **Frozen** 的库。Frozen 很酷。但它有这个，嗯，**最小完美哈希（minimal perfect hashing）**。最小完美哈希，真的引起了我的注意。我就想，好的，我可以在编译时做这个，它将根据键优化哈希函数。它是最小的。所以它将是尽可能小的。然后它是完美的，这就像，你不能比这更好了。所以我对此超级兴奋。

这里有一些基准测试。`std::map` 是蓝色的，所以 `unordered_map` 是橙色的。比如它是好的。这不是好的。嗯，它是，它是线性的，或者是对不起，它不是线性的。它像 `log n`。但是二分搜索也有数据依赖性，比如，你知道，你如何分支，你知道，在一个非常小的流水线上，比如五级流水线或更少。这不理想。但是一旦你开始获得比那更多的，你就开始引入分支，分支预测错误或者，你知道，流水线停顿。那不好玩。而且像 `std::map` 对于局部性来说太糟糕了。不要用 `std::map`。

嗯，是的。所以我做嵌入式工作，嗯，我们需要像拥有高效存储以及性能。所以这些是我们的数据集。一、二、三、四、五、六、七、八、九个条目。我做了 10 到 90，100 到 900。我也做了 1000 到 9000。事实证明我不需做那个。嗯，我们喜欢，你知道，这就像一个，我们要么住在这里，对吧？对于，对于我们要做的。所以我们希望这很快。

Frozen map 的性能在大小方面看起来并不差。实际上在大小方面，Frozen map 是完美的。比如这个是有序 map。所以它只是所有条目的排序数组。对吧。然后它在上面做一个二分搜索。

所以我们要使用 Frozen，对吧？嗯，它还不够好。我的意思是，我想要更多。嗯，我不像妥协。像一个好的工程师不会在任何事情上妥协，对吧？你有你所有的限制，你满足一切而不妥协。嗯，不幸的是不是。

但后来我看到了 Chris Jouziak 的一个库，嗯，**MPH**。完美哈希库（Perfect hash library）。比如，当然。好的。我必须看看这个是完美的。嗯，所以我正在看 GitHub，我看到这个例子，我看代码。比如这是代码生成（codegen）。我就想，这到底是怎么回事？比如 Frozen 的代码生成是像这样的，对吧？不。不。Frozen 的代码生成从那里的顶部到这里，在这个字体大小下。嗯，它就像基本上没有分支。所以这是它在嵌入式系统上对于像小型微控制器来说会有多快的一个好指标。

所以我试图理解这里发生了什么。我理解失败了。我不知道那条指令是什么。有人知道那是什么吗？这很酷。**并行位提取（parallel bit extract）**。非常酷。所以我把它加到我的基准测试中。我就想，哦我的上帝，看那个。比如这里发生了什么？嗯，我的数据更进一步，但我在和 Chris 谈话。嗯，我就想，他是像，嗯，你不应该真的把它用于更多。这就像，它是打算用于更小的尺寸，因为，嗯，我没有尺寸图，但是当你加入像尺寸时，它就像有点直线上升。这是一个完美哈希函数，这很棒，但它不是一个最小哈希函数。一个完美哈希函数也可以是，你知道，一个 4GB 数组上的恒等函数，对吧？它是完美的。你不会得到任何冲突。你也永远不会命中缓存。嗯，但这就像，好的，我想要那个，对吧？我非常想要那个。嗯，我的嵌入式处理器上没有这条指令。这是一条非常专门的指令。我就想，但我，哦，它太好了。我不能放过那个。所以。

> **听众提问：** 他的代码是输出字面量 `PEXT` 还是他生成的？他在写编译成那样的代码吗？

是的。所以他写的代码被编译成它，它叫做像下划线 `PEXT`。所以他在使用一个 intrinsic。是的。嗯，对不起。

让我们放大一点。这延迟太荒谬了。它是，它是，嗯，没有什么能碰到它真的。而且它在所有方面都是一致的。所以这有点让我大吃一惊。记得我说过只有像两件事我需要看性能。嗯，这让我分心了。嗯，但这值得。这是值得的。

所以这做的是基本上你，你给它一个，你给它一些数据，然后你给它一个掩码（mask）。这是你的源数据。掩码是控制。掩码基本上说对于这些位中的每一个，我想提取那个。所以这很酷。它就像一个按位与，对吧？不，因为它拿走那些位，然后把它们全部打包。这真的很酷。

我就想，这怎么作为一个哈希函数工作？我不理解这个，因为我花了那么多时间。如果你看我去年在 MBL++ 的演讲，我花了那么多时间，比如弄清楚，哦，你只要做一大堆像快速但糟糕的哈希函数，然后遍历它们。希望其中一个会足够好。也足够快。这是一个算法，它挑选用于你的键的掩码，以找到一个没有冲突的掩码。而且它，它变得比那更酷。

所以我看着这个，我很嫉妒，我想要这个。我试图弄清楚这是如何工作的。比如，好的。所以你做的是做我刚才说的。你，你弄清楚我能用什么掩码，我遍历所有的键，它们仍然都是唯一的。没有冲突，对吧？这实际上一点也不坏，实际上。我可以理解它。

所以然后你生成表。你，你填充它。我的算法是如果没有找到东西，你使用默认值。它对于索引工作得很好。用默认条目填充它。然后你就经历像，哦，我只要，你知道，拿掩码，做那个，把它放入表中。你的表需要很大。2 的多少次方，取决于需要多少位，对吧？所以如果你需要 6 位让它唯一，那么你需要，你知道，你知道，一个 64 位条目的表。那不大。它会变大。

> **听众提问：** 也许我跳得太快了，但是当我说，当我看到有东西说，嗯，表不应该太大，我开始想两级表。

是的，我也是。是的。是的。是的。

所以我当时在想各种疯狂的事情。它们大多数，比如，是疯狂的。但我有一个任务。

所以查找是如何工作的？你用你的掩码对键应用 PEXT。你直接索引到表中。你得到条目。然后你只要检查，那是正确的吗？因为它可能不是，对吧？你可能有别名（aliasing）。如果是，你返回那个。除非你只返回默认值。这太简单了。比如，这，你知道，只是几条指令，就像我们看到的那样。比如，Chris 没有在开玩笑。

所以，我仍然想要这个。

> **听众提问：** 你说你可能有别名，但它不是完美的吗？

不，你可能有别名，因为你不能信任你得到的数据。你可能正在获取一个你没有的键。它不存在那里。然后它可能别名。对吧？

> **听众提问：** 你有问题吗？好的。所以我怎么能做一个并行位提取？

> **听众提问：** 我想问，MPH 有其他策略，你测试了除 PEXT 之外的任何一个的性能吗？

我真的只对这一个感兴趣。是的。Chris 在他的页面上有一堆基准测试。而且他，自从我开始和他谈话以来，他发了两个版本。所以。

> **听众提问：** 你可以打开《Hacker's Delight》并找到它的算法？

不。我的意思是，那本来会很酷。这是一个算法，对吧？这是一种做它的方式。这太糟糕了。不。是的。看，事情是，这不会足够好，因为，嗯，你会一会儿看到的。我可以做的是我可以提取每一位，然后我可以把它打包。对吧？这就是这个做的。这很慢。永远不要做这个。我也可以像寻找位的游程（runs），然后打包它们。那好一点。对吧？

> **听众提问：** 既然你在控制所有数据，而且方式更好，你需要完全使用 PEXT 吗？因为你就像把所有的位打包在低部分，只使用这些位。

架构师定义了位编码。

> **听众：** 好的。

不幸的是，我们对他们来说不是最重要的人，而且有遗留问题。所以，是的，我们不，这是，这是我们需要有延展性的地方。我们需要适应我们得到的任何东西，因为我们将不得不以某种方式处理它。好的。

所以这是，是的，那是一个糟糕的算法。所以我开始 Google，我来到 Stack Overflow，这看起来像是来自像国际象棋算法的东西，也许，你知道，把位打包进 64 位编辑器，但是像，好的，使用乘法的一些有趣技术。我点击某人的，像，哦是的，乘法。它是一堆移位和加法，对吧？所以我们可以把东西移来移去。我可以按照我想要的方式对齐位，对吧？所以 12 乘以 5，对吧？这就过一遍。乘法，对吧？12 乘以 5 等于 60。嗯，12 移位 0，因为我们有第 0 位设置。12 移位 2，因为我们有 0，1，2，这个位设置。我们把它们加在一起。嘿，那是 60，对吧？

为 4 位归纳。我们在另一边有 4 位 ABCD。在另一边，我们选择我们要加入哪些移位，对吧？我们遍历并将加入那些启用的。这就是我想要的。我想能够把我的位排成一行。好的。所以如果是这种情况，我应该能够找到。

所以首先我想掩码出我感兴趣的位。这些是我想要使用的位。这些，这些位是如果我处理它们就能保证所有键都是唯一的位。然后我想弄清楚某个**魔数（magic number）**。所以我得到感兴趣的位。它们没有被打包在一起。但是如果我乘以这个魔数，它们将全部被打包在一起。它们将被向上移动一点，我将不得不把它们移回来。然后会有很多垃圾从进位中带上来，因为我在做加法，对吧？而且我没有在每次移位时掩码掉。所以有一堆像其他的噪音。

所以这不会是一个完美的并行位提取，对吧？会有重叠。会有，你知道，发生我不想要的加法。会有进位被传播。这不是一个真正的 PEXT。它是一个**伪 PEXT（pseudo-PEXT）**。所以编译器永远不会像优化这个并像，哦是的，做一个乘法。那足够好，某种程度上。但它对于哈希来说足够好。它对于哈希来说太棒了。

所以这里有一个例子。我想提取这个位。这将是位 A。这将是位 D。我想从这个值中提取这两个，对吧？我们的魔数是 5。它就是。那里，我会更多地解释这个。所以我们需要做的是乘以 5。那将拿这个。它将把它保持在这里，因为第 0 位设置了。它将把这个移过去，因为第 2 位设置了。把它们加在一起。看看这个。我们让这两个家伙紧挨着，对吧？那很有希望。然后把它移过去。移位很容易。没什么大不了的。然后你掩码它。这就有了。我们有了一个伪 PEXT。选择这个例子是为了位没有冲突。没有东西被加在一起。碰巧，事实证明这并不重要。对吧？我就想，哦，我需要一个更复杂的算法来以最优的方式做这件事以最小化那个吗？不。我不。而且我没有。所以谢天谢地。那本来会花很多时间。

所以看这个算法真的很容易。基本上，在掩码中找到每一个连续的 1 的游程，对吧？然后计算它需要被移动多远。所以最高数量的 1，你把它们保持在原位。下一级 1，你把那些移过去。下一级 1，你把那些移过去。这就是为什么它最终比之前的要高。对吧？然后你就不用担心其他正在相加的位。对吧？没关系。

所以哈希函数通常是移位、异或和乘法。对吧？它们就像，它们真的，人们像寻找只是某种程度上把位搅乱的数字，对通用，你知道，数据集有好处。这对于特定的已知值比那个好得多。

当我看到这个时我很开心。蓝色的是 PEXT。它是 Chris 的算法。绿色的是伪 PEXT。它慢一点点。相信我。但这是一千个条目，它保持了那个性能。所以我真的，真的像为此感到兴奋。这是大小。所以这就是为什么 Chris 像，是的，你不应该真的把它用于超过 60。是因为，你知道，你在嵌入式微控制器中不能做任何其他事情，但你可以非常快地查找表。一张表非常快。

所以它是完美的，但它不是完美的。你知道，它是完美的在于没有冲突。你知道吗？冲突并没有那么糟糕。它们实际上像真的，真的很有用。我们可以做的另一件事是我们可以添加另一层间接。比如我们为我们的整个条目有一大堆空白空间，对吧？但我们只有一百个条目，比如说。嗯，你可以索引到最终存储，对吧？所以你可以有一个更小的查找表作为更小的类型。所以让我们加上那个。是的。它没那么糟糕，但它仍然不够好。所以通过一层间接，我们节省了一些存储。

但我们可以做的是现在它不必是完美的，对吧？所以那个间接的仍然是完美的。它不必是完美的。如果我们得到一些冲突，没关系。因为像，记得我说过线性搜索对于少量元素来说实际上像真的很快吗？它仍然很快，即使你是作为哈希算法的一部分在做它。如果你是像在内存中跑过，对吧？连续的位置。

所以我们要弄清楚我们如何更新我们的掩码搜索算法以允许冲突。我们拿，所以这是完美掩码，对吧？完美。好的，只要我们配置为搜索长度大于 1，我们也想最终停止，对吧？我发现了那个。所以如果我们降到了像 16 个条目，你知道，中间表，那太棒了。比如那很好。我们不需要比那更多。

我们做的是，我们找到我们可以移除的那个导致最少冲突数量的位，对吧？只是一个位。所以我们去检查所有的，哪一个导致最少数量的冲突。好的，让我们试试那个。然后我们检查最大值，像最坏情况的冲突数量。我们将不得不处理的最大桶是多少？如果它仍然小于我们的最大搜索搜索长度，像，好的，我们要，我们要保留那个。然后我们要再次通过。我们要继续移除位。我们要继续尝试移除导致最少冲突数量的位。

事实证明这太棒了。所以只是两个，每个桶只是两项就把我们带到了这里。对吧？这比 Frozen `unordered_map` 好。这在大小方面比 `std::map` 和 `std::unordered_map` 好。然后有收益递减，但它只是变得越来越好。是的。所以最好的是所有的伪 PEXT，搜索为 2、3 和 4。然后 Frozen map 是完美的，因为它只是排序元素的数组，它在做一个二分搜索。

性能实际上也非常棒。所以我们有，我只是要把所有这些家伙加进去。比如它们都在这里挤在一起。它们都极快。它们和那些其他算法在像一个完全不同的类别上。所以这是针对一百个条目，每个条目是一个 16 位键，一个 16 位值。那是一个不错的区域，但我也有一些针对 32 位的基准测试，显示类似的结果。一千个条目。我们不会有一千个条目的表，但我希望能知道如果我想的话我可以。如果我因为某种原因必须的话。

所以像这些是非常合理的值。这是 66% 的存储效率，对吧？哈希通常像，这是对于哈希图来说合理的存储效率。所以我们在 66% 对于一千个条目，83% 对于一百个条目。所以那相当棒。看看速度。即使在一千个条目，它也没有变得，比如那里，它很快。它仍然很快。

所以那太棒了。是的，数学和科学太棒了。搜索和研究以及只是，你知道，建立联系和尝试不同的事情很有趣。

所以让我们把它放在一起。记得我说过有两件事你必须拥有性能，对吧？去年我在一个代表嵌入式系统的开发板上运行了这些基准测试。这是开发板。它不容易获得。它很贵。你为什么要买它？对吧？所以这不是一个像重现基准测试的好方法。所以我希望人们能够重现这些基准测试。这个处理器，我的意思是，它，它，它很酷。但有像一个非常微小的细节，像真的，真的微妙，你可能注意不到。我不知道，像，是的。所以希望那是，那是显而易见的。

去年我对整个索引算法，整个，你知道，分发算法运行了基准测试，150 个回调，每一个不同的字段。我只是遍历一个消息列表，我在实际硬件上进行基准测试。我得到了这个。这是索引处理程序的分发速度，对吧？它像在 400 兆赫兹的顺序处理器上小于 145 纳秒。那太棒了。这是朴素的方法，它只是遍历所有的回调。这里有像红旗。比如编译器崩溃了，对吧？这做得很好，做得很好直到像这里。它就像，嗯，我要放弃了。我不知道这里发生了什么。然后不知何故当你添加更多时它变得更好了。我不知道这到底是怎么回事，但这非常糟糕。这是在实际硬件上运行的。所以我就想，我不像，好的，我得看看那个。我真的需要再看看这个，因为这快了几个数量级。

一年的变化已经在库中发生了。我现在在一个大核心上运行。我现在像在一个 x86 处理器上运行。我试过在我的笔记本电脑上运行。我的笔记本电脑从未给出一致的结果，因为有像一堆东西在后台运行。它是我的公司笔记本电脑。所以我在云机器上运行，Google 和，你知道，Google N2 实例运行 Cascade Lake，非常一致。非常一致，但是这，所以我昨晚跑了我的基准测试，然后我今天早上又跑了一遍，我忘了更新这个。

所以这最底下的一个，这是朴素方法。这是所谓的“朴素”方法，你在遍历所有 200 个。我的意思是，我的代码在遍历所有的回调，然后评估谓词。所以，编译器一定在做优化并结合，把事情结合成像二分决策树之类的东西，因为这比我预期的要好得多。索引查找是 20 纳秒。所以它更快。它不像，你知道，它是快了一百倍。不是那样的。

但这里的另一件事，这个朴素查找仍然在使用 CIB 库。所以即使我们在编译时用特性扩展所有这些东西，处理程序知道所有这些谓词，它可以，编译器可以内联所有这些。对吧。因为它就像我们在直接调用它们并被内联一样。所以编译器在这里能够做很多我没预料到的优化。这需要被调查。

我们有另一种存储回调，set callback sets 的方式，以便我们可以做一个高效的存储然后交集，比预期的慢得多。但我们还没花，还没花时间改进那个。

所以，是的，我对这些结果真的很失望。它实际上相当好。它快了两倍。而且如果，如果你有一个类型擦除系统，你在运行时注册东西，你不会得到这种性能，即使在朴素，朴素实现中。然后也就是在此之上，像编译器变化，一些库变化。现在这是一个乱序处理器。对吧。所以也许像拥有一个函数指针数组。对吧。并且实际上有一个随机索引进入它，像，哦，是的，我想执行那个函数指针处的代码。对于 CPU 来说可能不那么容易优化。它真的不能推测（speculate）。对吧。它每次都会推测错误。

一些经验教训。所以有些事情我们应该害怕，有些事情我们不应该害怕。你不应该害怕变化。你不应该害怕修复事情和改进事情。你应该有点害怕拥有错误的接口。比如你应该对制造错误的接口有一种健康的恐惧。

所以让我们创建好的接口，依赖它们。诱导出基本概念。比如什么是第一性原理？然后拿那些基础并将它做成一个声明式接口。只是声明式描述你想要的。然后你在那另一边的实现可以自由地做许多不同的事情。

如果你依赖像布尔代数这样稳定的概念，比如，好的，它已经存在至少几百年了。我不知道多少年。你知道吗，Ben？

> **Ben:** 在我出生之前。

是的，1800 年代。所以它是古老的。可能早几个世纪在印度发明。是的。是的。我的意思是，这些是被充分理解、充分研究的东西。所以如果你的基础是那个，那是一个好兆头。

我们什么时候优化？嗯，不要在你做演示的前一天优化。那不会带你去你想去的地方。不要在几周前做，因为你会分心于某事而不是像，你需要测量来知道你必须在哪里优化。对吧。但性能要求。所以，所以性能要求应该指导我们的设计。所以我们的整体设计，像我知道我必须快。所以让我们确保我可以变快。对吧。然后在你有证据表明必要时优化实现。你将接口与性能解耦。

所以我很难过它没有那么快，因为说像，哦是的，这快了一百倍会很酷。这太惊人了。每个人都应该用这个。但这实际上完全没问题，因为我们总是可以稍后让它更快。对吧。而且我们不必为此改变我们的接口。

所以谢谢大家。

> **听众：** 很棒。很棒的演讲。非常感谢。嗯，我打算先问个问题。嗯，所以你提到哈希函数是，嗯，不是最小的。所以你基本上有点像在编译时，启发式地寻找各种哈希函数，直到你找到一个好的，没有太多冲突也不太大的表。所以你能谈谈一点关于，嗯，比如你的搜索什么时候结束，或者，嗯，你有像一个非常非常长的，嗯，搜索当你为像发布模式编译时，还是小，这有关系吗？

测试模式和发布模式对我们来说是一样的。嗯，我们总是用 O3 编译。我们只是每次都用同样的方式编译。有更少的东西要验证，对吧？就像，哦，这个测试失败了。哦，但我是在调试模式下做的。好的。如果我做发布模式会重现吗，反之亦然？对吧。所以那有点痛苦。嗯，基本上像，如果你，如果你看图表，搜索长度为 2 真的很好。所以那是索引的默认值。

> **听众：** 所以那是标准。所以它一直搜索直到，直到它到达一个点，比如，我不能在不超出最大搜索长度的情况下移除任何位，对吧？

> **听众：** 两次编译是，嗯，像一致地以相同的顺序搜索然后找到相同的匹配吗？还是有任何方式让随机 C 随机性进入编译案例？

没关系。如果键集不改变，它是一样的。这是一个确定性算法。是的。

> **听众：** 但要找到像那个初始掩码，如果你从最高有效位开始，你会得到一个与从最低有效位开始不同的掩码。

所以我从最高有效位开始，因为很多时候像低位，如果你能移除所有高位，很多时候你会在底部得到一段连续的位。然后你不需要做乘法。像，编译器很聪明。就像，哦，你乘以 1 然后你移位 0，对吧？那只是一个 AND 好了，然后一个掩码。所以三个操作。所以它只是摆脱了移位，摆脱了乘法。它只是作为掩码。是的。是的。

> **听众提问：** 在显示收益递减的图表上。所以这是一个测量正在使用的尺寸的图表。

是的。

> **听众：** 确保我理解正确，权衡是因为这个的大小导致的查找时间。

是的。是的，是的，完全正确。

> **听众：** 所以，嗯，是的，但是你知道，说实话这并不是什么权衡。

所以这是针对一百个条目，针对一千个条目。所以搜索长度为 4，2.06 纳秒。搜索长度为 2，1.99 纳秒。

> **听众提问：** 你有没有发现像一个好的，像，平衡那两个参数的最佳点？或者它取决于使用情况...

我，我觉得像搜索长度为 2 相当好。像已经，只是，只是允许每个键一个冲突，它相当好。它产生了巨大的差异。像，嗯，没有冲突，没有冲突。你有 10% 的利用率，36 KB。允许一个冲突，12 KB，对吧？30，32%。允许三个。它只是变得越来越好。

所以这有点像，这取决于，嗯，针对我有的某个数据集，像针对特定的用例。所以像，你知道，搜索长度为 2 极好。从大小 4 KB 变成了像 400 字节。我就想，是的，我可以接受。那是，我，我在之前拼凑了一个糟糕的查找算法，这正在取代它。所以我对此非常满意。

> **听众提问：** 所以，嗯，对于，像如果一个特性有，或者一个服务有像更多字段会发生什么？是的。像你有错误的哈希图。

是的。所以可能发生的是，所以现在你必须指定像对于索引消息服务，你必须告诉它，在这些字段上建立索引。你必须做那个正确，对吧？你必须把它放在正确的字段中。它不会做任何检查。它不能。现在可能发生的另一件事，这可以在未来改变，这可以在未来修复。像你可以有像用于 PCIe 消息的 PCI Express 处理程序。但是然后你像添加了一个 USB 回调。那在运行时不会正确工作，但目前没有机制防止那个，但这可以被避免。

> **Roy 提问：** 所以冲突的成本基本上是，我认为，分支和分支预测错误有时。我不确定是不是这样。如果你有一个深流水线处理器和一个糟糕的预测器，很难把那些东西放回去，那你可能会受苦。

所以用这个数据，我运行基准测试的方式，这些总是命中，对吧？但我实际上遍历了整个列表。所以每次通过微基准测试的迭代，我都在选择表中的下一个条目，它可能在实际哈希图中的任何地方。所以这应该考虑了分支错误预测。是的，当然。

> **Roy：** 所以我想说的是，有关于这个叫 **SWAR** 的概念的演讲，我想是由 Eduardo 还是谁讲的，我认为这相关或适用于嵌入式，你在一个算术操作中查看整个冲突列表，并在两个或三个或四个短冲突列表中找到索引。所以也许...

是的，我认为那是我需要研究的东西。Chris 的库也有一个 SWAR 算法。是的。

> **听众提问：** 所以只是为了确保我在同一页面上，一千个条目意味着你有一千个回调映射到进来的同一个消息结构。

哦。所以对于这一个，这只是一个查找。所以这不像是整个回调和所有东西。所以那没关系。但在最后，我有针对...

这里。所以这是 256 个回调。每个回调在三个不同字段上有三个要求。它对三个不同字段有要求，对吧？所以这是针对整个索引算法。这是针对那个的基准测试，对吧？所以我们要么得到像快 40%。

> **听众：** 所以那是总搜索空间，而不是必须匹配的事物数量。

是的。所以在这个基准测试中我们只匹配三个字段。是的。

> **听众提问：** 通常匹配的数量是多少？像你收到一条消息，现在我必须做两个或三个或 10 或 20 个回调。

这就像你可以用一只或两只手以此数出来，像匹配的回调数量可能。

> **听众提问：** 当匹配发生时，里面有什么指定了如果有多个东西匹配同一条消息，有什么指定了它们必须被执行的顺序吗？

目前没有。这是我想过的事情。我有点，我宁愿不做那个。思考不同的事情是独立的很好，但有时有依赖关系。我们还没有需要做那个。谢谢。是的。

> **听众提问：** 我有一个关于回到表达式简化的问题。好的。在最根部，你说像，哦，这里是 true，因为它是一个动态的，对吧？

哦，好的。如果我说动态，我很抱歉。我不意味着动态。非索引。

> **听众：** 推入 lambda。是的。相对于静态评估或在更高处评估。

是的。

> **听众：** 但后来我有一个关于那如何牵连到一些的问题，如果你回到你开始它的树。

我有很多幻灯片。

> **听众：** 推入 lambda 就像是阐述的早期阶段。是的。嗯，你不需要你推入 lambda 的代码，只需要你开始简化的树。

是的。我在找它。我会找到它的。

> **听众：** 哦，好的。那就是我在做的。我在看我的幻灯片更短。

> **听众：** 所以是这个吗？不，是可见树的那个。哦，像 AST。是的。哦，好的。是的。

> **听众：** 所以就在这里你说像，好的，C 我们推入 lambda，但 A 和 NOT B，我们在更早评估。

好的。好的。所以。

> **听众：** 把 C 推入 lambda 并且你简化，你移除了在该阶段放 NOT B 的能力，并且也必须把 NOT B 推入 lambda，不是吗？

我们不必评估 NOT B，因为 C 总是真的。

> **听众：** 但 C 只是因为你要在 lambda 中重新评估它的真实性才是总是真的。

所以一般来说，我们不把东西放入 lambda。那就像一个早期阐述。像把东西放入 lambda 通常不是做法。所以我们在谈论三件不同的事情。

好的。有索引字段和非索引字段。所以你在谈论 C，我说我要移除 C，因为它是一个索引字段。

> **听众：** 哦，我以为你移除 C 是因为它是一个非索引字段。

不，因为它是一个索引字段，对吧？所以当我们来评估谓词的其余部分时，它保证是真的。是的。

> **听众：** 我明白了。我把它搞反了。好的。好的，酷。

> **听众提问：** 我有一个问题。所以你提到像编译器，优化器，做这类事情是它们的家常便饭，但它们可以在我们自己的类型和我们自己的 DSL 上做。所以我不知道是否有任何方式黑进系统。例如，C++ 20 概念确实有这种像试图规范化像包含规则的概念，取布尔表达式，试图规范化它们，然后试图找到最佳匹配，等等，等等。是否有任何尝试试图将那个强制进入...

如果是可能的，我不知道是不是，如果可能的话，我还是每次都更喜欢 Ben 的代码。是的。

好的。谢谢大家。

谢谢。

好的。好的。好的。好的。
